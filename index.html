<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
    <title>Lofi Radio — 24/7 Chill Beats</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap');

        :root {
            --bg-deep: #050505;
            --glass-panel: rgba(20, 20, 20, 0.6);
            --glass-border: rgba(255, 255, 255, 0.08);
            --text-main: #ffffff;
            --text-muted: #9ca3af;
            --dynamic-color: #e0aa3e; /* Updates via JS */
            --radius-xl: 24px;
            --radius-lg: 16px;
            --sidebar-width: 260px;
            --app-height: 100dvh; /* iOS Fix */
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Plus Jakarta Sans', sans-serif;
            height: var(--app-height);
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- DYNAMIC BACKGROUND --- */
        .ambient-glow {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: radial-gradient(circle at 50% 50%, var(--dynamic-color), transparent 70%);
            opacity: 0.15;
            z-index: 0;
            transition: background 3s ease; /* Slower transition */
            pointer-events: none;
        }
        .noise-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjMDAwMDAwIi8+CjxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9InJnYmEoMjU1LDI1NSwyNTUsMC4wOCkiLz4KPC9zdmc+');
            opacity: 0.6;
            z-index: 1;
            pointer-events: none;
        }

        /* --- LAYOUT GRID --- */
        #app-container {
            display: grid;
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: 1fr 100px;
            gap: 16px;
            width: calc(100% - 32px);
            height: calc(100% - 32px);
            z-index: 10;
            position: relative;
        }

        /* --- GLASS PANEL MIXIN --- */
        .glass-panel {
            background: var(--glass-panel);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px); /* iOS Safari */
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-xl);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            transition: border-color 0.3s ease;
        }

        /* --- SIDEBAR --- */
        .sidebar {
            grid-column: 1;
            grid-row: 1 / 3;
            display: flex;
            flex-direction: column;
            padding: 24px;
        }

        .brand {
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: -0.03em;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 40px;
            color: #fff;
        }
        .brand-icon {
            width: 32px; height: 32px;
            background: var(--dynamic-color);
            border-radius: 8px;
            box-shadow: 0 0 20px var(--dynamic-color);
            transition: background 2s ease, box-shadow 2s ease;
        }
        .brand-tagline {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: 500;
            margin: 4px 0 20px 0;
            letter-spacing: 0.02em;
        }

        .nav-menu { list-style: none; display: flex; flex-direction: column; gap: 8px; }
        .nav-item {
            padding: 12px 16px;
            border-radius: var(--radius-lg);
            color: var(--text-muted);
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex; align-items: center; gap: 12px;
        }
        .nav-item:hover, .nav-item.active {
            background: rgba(255,255,255,0.05);
            color: #fff;
            transform: translateX(4px);
        }
        .nav-item.active { color: var(--dynamic-color); }
        .nav-item svg { width: 20px; height: 20px; fill: currentColor; }
        .nav-item .nav-link { display: flex; align-items: center; gap: 12px; color: inherit; text-decoration: none; }
        .nav-item .nav-link:hover { color: inherit; }

        .library-box {
            margin-top: auto;
            background: rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: var(--radius-lg);
        }
        .lib-title { font-size: 0.75rem; font-weight: 700; color: var(--text-muted); letter-spacing: 0.05em; margin-bottom: 12px; }
        .playlist-tag {
            display: inline-block;
            font-size: 0.8rem;
            padding: 6px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            margin: 0 4px 8px 0;
            cursor: pointer;
            transition: 0.2s;
            white-space: nowrap;
        }
        .playlist-tag:hover { background: var(--dynamic-color); color: #000; font-weight: 600; }

        /* --- MAIN VIEW --- */
        .main-stage {
            grid-column: 2;
            grid-row: 1;
            padding: 40px;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            scrollbar-width: none;
        }
        .main-stage::-webkit-scrollbar { display: none; }

        /* Top Header */
        .stage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
        }
        .live-tag {
            padding: 6px 14px;
            background: rgba(255, 0, 0, 0.15);
            color: #ff4444;
            border: 1px solid rgba(255,0,0,0.3);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 700;
            display: flex; align-items: center; gap: 8px;
        }
        .live-dot { width: 6px; height: 6px; background: #ff4444; border-radius: 50%; animation: blink 2s infinite; }

        /* Hero */
        .hero-layout {
            display: flex;
            gap: 40px;
            align-items: flex-end;
            margin-bottom: 40px;
        }

        .album-art-container {
            width: 260px; height: 260px;
            flex-shrink: 0;
            border-radius: 24px;
            background: linear-gradient(135deg, #1a1a1a, #000);
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        /* Dynamic Art Gradient */
        .album-art-container::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%; width: 200%; height: 200%;
            background: conic-gradient(from 0deg, transparent, var(--dynamic-color), transparent);
            animation: rotateArt 10s linear infinite;
            opacity: 0.3;
            transition: background 2s ease;
        }
        @keyframes rotateArt { 100% { transform: rotate(360deg); } }

        .album-art-container:hover { transform: scale(1.02) rotate(-1deg); }
        
        #visualizer { position: relative; width: 100%; height: 100%; opacity: 0.8; z-index: 2; }

        .track-details h1 {
            font-size: 4rem;
            line-height: 1;
            font-weight: 800;
            letter-spacing: -0.04em;
            margin-bottom: 16px;
            padding-bottom: 1rem;
            background: linear-gradient(to bottom right, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            transition: opacity 1s ease;
        }
        
        .meta-badges { display: flex; gap: 12px; margin-bottom: 24px; }
        .badge {
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            background: rgba(255,255,255,0.1);
            color: var(--text-main);
            transition: background 2s ease;
        }
        .badge.accent { background: var(--dynamic-color); color: #000; }

        .action-row { display: flex; gap: 16px; align-items: center; }
        .play-btn-lg {
            width: 64px; height: 64px;
            border-radius: 50%;
            background: var(--dynamic-color);
            border: none;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            color: #000;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .play-btn-lg:hover { transform: scale(1.1); box-shadow: 0 0 40px var(--dynamic-color); }
        .play-btn-lg svg { width: 32px; height: 32px; fill: currentColor; margin-left: 4px; }

        /* Tracklist */
        .queue-section {
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius-lg);
            padding: 8px;
        }
        .queue-row {
            display: grid;
            grid-template-columns: 40px 1fr 100px 60px;
            padding: 16px;
            align-items: center;
            border-radius: 12px;
            transition: background 0.2s;
            cursor: default;
        }
        .queue-row:hover { background: rgba(255,255,255,0.05); }
        .queue-row.active { background: rgba(255,255,255,0.08); }
        .queue-row.active .q-title { color: var(--dynamic-color); }
        
        .queue-header { font-size: 0.75rem; font-weight: 700; color: var(--text-muted); letter-spacing: 0.05em; margin-bottom: 12px; padding: 8px 16px 0; }
        .q-num { color: var(--text-muted); font-size: 0.9rem; }
        .q-info { display: flex; flex-direction: column; }
        .q-title { font-weight: 600; font-size: 1rem; margin-bottom: 2px; }
        .q-artist { font-size: 0.85rem; color: var(--text-muted); transition: opacity 1s ease;}
        .q-meta { font-size: 0.85rem; color: var(--text-muted); font-weight: 500; text-align: right;}

        /* --- FLOATING PLAYER DECK --- */
        .player-deck {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 32px;
        }

        .deck-info { display: flex; align-items: center; gap: 16px; width: 30%; }
        .deck-art { 
            width: 56px; height: 56px; 
            background: #333; 
            border-radius: 12px; 
            overflow: hidden; 
            position: relative; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .deck-art::after { 
            content: ''; 
            position: absolute; 
            inset:0; 
            background: linear-gradient(45deg, #333, var(--dynamic-color)); 
            opacity: 0.5; 
            transition: background 2s ease;
        }
        
        .deck-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 40%; }
        .deck-buttons { display: flex; align-items: center; gap: 24px; }
        .deck-btn { background: none; border: none; color: var(--text-muted); cursor: pointer; transition: color 0.2s; }
        .deck-btn:hover { color: #fff; }
        .deck-btn.main { 
            width: 40px; height: 40px; 
            background: #fff; color: #000; 
            border-radius: 50%; 
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s;
        }
        .deck-btn.main:hover { transform: scale(1.1); }

        .progress-container { width: 100%; display: flex; align-items: center; gap: 12px; font-size: 0.75rem; color: var(--text-muted); font-weight: 600; font-variant-numeric: tabular-nums; }
        .prog-track { flex: 1; height: 6px; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden; }
        .prog-fill { height: 100%; width: 0%; background: var(--dynamic-color); border-radius: 10px; transition: width 1s linear, background 0.5s ease; }

        .deck-volume { width: 30%; display: flex; justify-content: flex-end; }

        /* Icon Utility */
        .icon-play, .icon-pause { display: none; }
        .show-icon { display: block; } 

        /* FADE UTILS */
        .fade-out { opacity: 0; }
        
        /* --- SPOTIFY CANVAS: Looping video background --- */
        .canvas-video-wrap {
            position: fixed;
            inset: -2px;              /* Bleed past edges to kill any seam */
            z-index: 3;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.8s cubic-bezier(0.4, 0, 0.2, 1);
            display: none;
            overflow: hidden;
        }
        .canvas-video-wrap.visible { opacity: 1; }

        /* Invisible tap zone — top half of screen toggles canvas */
        .canvas-tap-zone {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%;
            height: 50%;
            z-index: 55;
            pointer-events: none;
            -webkit-tap-highlight-color: transparent;
        }
        .canvas-video {
            position: absolute;
            top: -63px; left: 0;
            width: 100%;
            height: calc(100% + 63px);
            object-fit: cover;
            object-position: center top;
            /* Force own compositing layer so iOS paints video when parent opacity transitions */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }
        /* Hard-edge gradient strips: solid black → transparent to hide video seams */
        .canvas-vignette-top {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 18px;
            background: linear-gradient(to bottom, #050505 0%, transparent 100%);
            pointer-events: none;
            z-index: 1;
        }
        .canvas-vignette-bottom {
            position: absolute; bottom: 0; left: 0;
            width: 100%; height: 18px;
            background: linear-gradient(to top, #050505 0%, transparent 100%);
            pointer-events: none;
            z-index: 1;
        }
        .canvas-vignette-radial {
            position: absolute; inset: 0;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(5,5,5,0.45) 100%);
            pointer-events: none;
        }

        /* Canvas track overlay (floating above player deck) */
        .canvas-track-overlay {
            display: none;
            position: fixed;
            bottom: 110px;
            left: 0; right: 0;
            z-index: 50;
            padding: 0 24px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s ease;
        }
        .canvas-track-overlay.visible { opacity: 1; }
        .canvas-track-meta {
            text-align: center;
            margin-bottom: 16px;
        }
        .canvas-title {
            font-size: 1.8rem;
            font-weight: 800;
            letter-spacing: -0.03em;
            line-height: 1.15;
            color: #fff;
            text-shadow: 0 2px 24px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.5);
            margin: 0 0 6px 0;
        }
        .canvas-artist {
            font-size: 0.95rem;
            font-weight: 600;
            color: rgba(255,255,255,0.7);
            text-shadow: 0 1px 12px rgba(0,0,0,0.8);
            margin: 0;
        }
        .canvas-badges {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        .canvas-badge {
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 700;
            background: rgba(0,0,0,0.35);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.08);
        }
        .canvas-badge.accent { background: var(--dynamic-color); color: #000; border-color: transparent; }
        .canvas-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 320px;
            margin: 0 auto;
        }
        .canvas-time {
            font-size: 0.7rem;
            font-weight: 600;
            color: rgba(255,255,255,0.55);
            font-variant-numeric: tabular-nums;
            min-width: 32px;
            text-align: center;
        }
        .canvas-prog-track {
            flex: 1;
            height: 3px;
            background: rgba(255,255,255,0.15);
            border-radius: 10px;
            overflow: hidden;
        }
        .canvas-prog-fill {
            height: 100%;
            width: 0%;
            background: rgba(255,255,255,0.6);
            border-radius: 10px;
            transition: width 1s linear;
        }
        .canvas-scroll-hint {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin-top: 20px;
            font-size: 0.7rem;
            font-weight: 600;
            color: rgba(255,255,255,0.3);
            letter-spacing: 0.05em;
            text-transform: uppercase;
            animation: canvas-bounce 2.5s ease-in-out infinite;
        }
        .canvas-scroll-hint svg { opacity: 0.4; }
        @keyframes canvas-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(5px); }
        }
        
        /* --- MOBILE OPTIMIZATION --- */
        @media (max-width: 900px) {
            #app-container {
                display: flex;
                flex-direction: column;
                width: 100%;
                height: 100%;
                gap: 0;
            }

            .sidebar {
                display: none; 
            }

            .main-stage {
                padding: 20px;
                padding-bottom: 120px;
                width: 100%;
            }

            .hero-layout {
                flex-direction: column;
                align-items: center;
                gap: 24px;
                text-align: center;
                margin-bottom: 30px;
            }

            .album-art-wrapper { display: flex; flex-direction: column; align-items: center; gap: 12px; }
            .album-art-container {
                width: 280px;
                height: 280px;
            }
            .mobile-track-time {
                display: flex;
                align-items: center;
                gap: 10px;
                width: 100%;
                max-width: 280px;
                font-size: 0.8rem;
                color: var(--text-muted);
                font-weight: 600;
                font-variant-numeric: tabular-nums;
            }
            .mobile-track-time .mobile-prog { flex: 1; height: 4px; }

            .track-details h1 {
                font-size: 2.2rem;
                margin-bottom: 12px;
                padding-bottom: 0.75rem;
            }

            .meta-badges {
                justify-content: center;
                flex-wrap: wrap;
            }

            .action-row {
                display: none; /* Hide top play button on mobile */
            }

            .queue-row {
                grid-template-columns: 30px 1fr;
                gap: 10px;
                padding: 12px;
            }
            .q-meta { display: none; } 

            .player-deck {
                position: fixed;
                bottom: 16px;
                left: 16px;
                width: calc(100% - 32px);
                height: 80px;
                border-radius: 20px;
                padding: 0 20px;
                background: rgba(30, 30, 30, 0.85);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                border: 1px solid rgba(255,255,255,0.15);
                z-index: 100;
                display: grid;
                grid-template-columns: auto 1fr auto;
                gap: 12px;
            }

            .deck-info { width: auto; gap: 12px; }
            .deck-art { width: 48px; height: 48px; border-radius: 8px; }
            .q-title { font-size: 0.9rem; }
            .q-artist { font-size: 0.75rem; }

            .deck-controls { 
                width: auto; 
                flex-direction: row; 
                justify-content: flex-end;
            }
            .progress-container { display: none; } 
            .deck-buttons { gap: 16px; }
            .deck-btn { display: none; } 
            .deck-btn.main { display: flex; width: 44px; height: 44px; } 
            
            .deck-volume { display: none; }

            .mobile-vibes {
                display: flex;
                gap: 8px;
                padding: 0 0 20px 0;
                overflow-x: auto;
                width: 100%;
                -webkit-overflow-scrolling: touch;
            }
            .mobile-vibes::-webkit-scrollbar { display: none; }

            /* --- Canvas active state --- */
            .canvas-video-wrap { display: block; }
            .canvas-track-overlay { display: block; }
            .canvas-tap-zone { display: block; }

            /* Smooth transitions for hero when canvas toggles */
            .hero-layout {
                transition: opacity 0.8s ease, transform 0.8s ease;
            }
            .mobile-vibes {
                transition: opacity 0.6s ease;
            }

            /* Main stage: transparent glass, hero hidden, rest stays */
            body.canvas-active .main-stage {
                background: transparent !important;
                backdrop-filter: none !important;
                -webkit-backdrop-filter: none !important;
                border-color: transparent !important;
                box-shadow: none !important;
            }
            body.canvas-active .ambient-glow { opacity: 0 !important; }
            body.canvas-active .noise-overlay { opacity: 0.15 !important; }

            /* Hero fades out when canvas is active */
            body.canvas-active .hero-layout {
                opacity: 0 !important;
                pointer-events: none !important;
                transform: scale(0.96) !important;
                position: absolute !important;
                visibility: hidden;
            }
            body.canvas-active .mobile-vibes {
                opacity: 0 !important;
                pointer-events: none !important;
            }

            /* Stage header: keep floating at top, glassmorphic */
            body.canvas-active .stage-header {
                position: sticky;
                top: 0;
                z-index: 10;
                padding: 12px 0 16px;
                opacity: 1;
            }
            body.canvas-active .live-tag {
                background: rgba(255, 30, 30, 0.18);
                backdrop-filter: blur(12px);
                -webkit-backdrop-filter: blur(12px);
                border: 1px solid rgba(255,255,255,0.06);
            }
            body.canvas-active .badge {
                backdrop-filter: blur(12px);
                -webkit-backdrop-filter: blur(12px);
                border: 1px solid rgba(255,255,255,0.06);
            }

            /* Queue: push below the fold — user must scroll to see it */
            body.canvas-active .queue-section {
                margin-top: calc(100vh - 220px);
                background: rgba(0,0,0,0.35);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                border: 1px solid rgba(255,255,255,0.06);
                border-radius: 20px;
                padding-bottom: 140px; /* Extra space for player deck overlap */
            }
            body.canvas-active .queue-section::before {
                content: 'Next Up';
                display: block;
                padding: 16px 16px 8px;
                font-size: 0.85rem;
                font-weight: 700;
                color: rgba(255,255,255,0.5);
                letter-spacing: 0.06em;
                text-transform: uppercase;
            }
            body.canvas-active .queue-row:hover {
                background: rgba(255,255,255,0.08);
            }

            /* Player deck: translucent glass over video */
            body.canvas-active .player-deck {
                background: rgba(15,15,15,0.6) !important;
                backdrop-filter: blur(24px) !important;
                -webkit-backdrop-filter: blur(24px) !important;
                border-color: rgba(255,255,255,0.08) !important;
            }
        }
        @media (min-width: 901px) {
            .mobile-track-time { display: none !important; }
        }
    </style>
</head>
<body>

    <div class="ambient-glow" id="bg-glow"></div>
    <div class="noise-overlay"></div>

    <!-- Spotify Canvas: looping video background (mobile, fades in after 30s) -->
    <div class="canvas-video-wrap" id="canvas-container">
        <video class="canvas-video" id="canvas-video" src="video.mp4" loop muted playsinline preload="auto" autoplay></video>
        <div class="canvas-vignette-top"></div>
        <div class="canvas-vignette-radial"></div>
        <div class="canvas-vignette-bottom"></div>
    </div>

    <!-- Tap zone: top half of screen — tap to toggle canvas on/off -->
    <div class="canvas-tap-zone" id="canvas-tap-zone"></div>

    <!-- Canvas overlay: track info shown over the video when canvas is active -->
    <div class="canvas-track-overlay" id="canvas-overlay">
        <div class="canvas-track-meta">
            <div class="canvas-badges" id="canvas-badges">
                <span class="canvas-badge accent" id="canvas-style-badge">Classic</span>
                <span class="canvas-badge" id="canvas-mood-badge">Chill</span>
            </div>
            <h2 class="canvas-title" id="canvas-title">—</h2>
            <p class="canvas-artist" id="canvas-artist">—</p>
        </div>
        <div class="canvas-progress">
            <span class="canvas-time" id="canvas-time-current">0:00</span>
            <div class="canvas-prog-track"><div class="canvas-prog-fill" id="canvas-progress-bar"></div></div>
            <span class="canvas-time" id="canvas-time-total">--:--</span>
        </div>
        <div class="canvas-scroll-hint" id="canvas-scroll-hint">
            <span>Next up</span>
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
        </div>
    </div>

    <div id="app-container">
        
        <!-- SIDEBAR -->
        <nav class="sidebar glass-panel">
            <div class="brand">
                <div class="brand-icon"></div>
                <span>Lofi Radio</span>
            </div>
            <p class="brand-tagline">Beats to study, work & relax</p>
            
            <ul class="nav-menu">
                <li class="nav-item active" data-channel="lofi" id="nav-lofi">
                    <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                    Listen Live
                </li>
                <li class="nav-item" data-channel="ambient" id="nav-ambient">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-5.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"/></svg>
                    Ambient
                </li>
            </ul>

           
        </nav>

        <!-- MAIN STAGE -->
        <main class="main-stage glass-panel">
            <div class="stage-header">
                <div class="live-tag"><div class="live-dot"></div> LIVE</div>
                <div class="badge">24/7</div>
            </div>

            <div class="mobile-vibes" style="display: none;"></div>

            <div class="hero-layout">
                <div class="album-art-wrapper">
                    <div class="album-art-container">
                        <canvas id="visualizer"></canvas>
                    </div>
                    <div class="mobile-track-time">
                        <span id="mobile-time-current">0:00</span>
                        <div class="prog-track mobile-prog"><div class="prog-fill" id="mobile-progress-bar"></div></div>
                        <span id="mobile-time-total">--:--</span>
                    </div>
                </div>
                <div class="track-details">
                    <!-- Cleaned up mobile list -->
                    <div class="mobile-vibes-list" style="display:none; overflow-x:auto; gap:8px; margin-bottom:16px; width:100%; white-space:nowrap;">
                         <!-- Intentionally empty per request -->
                    </div>

                    <div class="meta-badges">
                        <span class="badge accent" id="style-badge">Classic</span>
                        <span class="badge" id="mood-badge">Neutral</span>
                        <span class="badge" id="bpm-badge">80 BPM</span>
                    </div>
                    <h1 id="playlist-title">Tune in to start</h1>
                    <div id="playlist-artist" class="playlist-artist" style="font-size: 1.1rem; color: var(--text-muted); margin-bottom: 16px; display: none;">—</div>
                    <div class="action-row">
                        <button class="play-btn-lg" id="playBtn">
                            <svg class="icon-play show-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                            <svg class="icon-pause" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                        </button>
                        <span id="play-prompt" style="font-weight: 600; color: var(--text-muted); font-size: 0.9rem;">Hit play to tune in</span>
                    </div>
                </div>
            </div>

            <div class="queue-section" id="queue-container">
            </div>
        </main>

        <!-- PLAYER DECK -->
        <footer class="player-deck glass-panel">
            <div class="deck-info">
                <div class="deck-art">
                    <!-- Icon Placeholder -->
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="rgba(255,255,255,0.5)"><path d="M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7z"/></svg>
                </div>
                <div>
                    <div class="q-title" id="bar-title">Tune in</div>
                    <div class="q-artist" id="bar-artist">24/7 Lo-Fi · Beats to relax</div>
                </div>
            </div>

            <div class="deck-controls">
                <div class="deck-buttons">
                    <button class="deck-btn"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg></button>
                    <button class="deck-btn main" id="barPlayBtn">
                        <svg class="icon-play show-icon" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                        <svg class="icon-pause" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    </button>
                    <!-- Next button hidden on mobile via CSS deck-btn class logic -->
                    <button class="deck-btn" id="nextBtn"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg></button>
                </div>
                <div class="progress-container">
                    <span id="time-current">0:00</span>
                    <div class="prog-track"><div class="prog-fill" id="progress-bar"></div></div>
                    <span id="time-total">--:--</span>
                </div>
            </div>

            <div class="deck-volume">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="#666"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
            </div>
        </footer>

    </div>

<script>
    /**
     * LOFI.FM AUDIO ENGINE v9.0 — Hit-only generation, famous progressions & patterns
     * + Ambient channel: Aether-style sound with 24h time-of-day logic
     *
     * Why Ambient feels snappier than Lo-Fi: Ambient uses the raw Web Audio API (one
     * AudioContext, no scheduler). Lo-Fi uses Tone.js: Transport + lookAhead scheduling
     * and a long effect chain (multiband, reverb, delay, etc.), which can add latency
     * and mastering artifacts. We keep lookAhead short and mastering gentle to reduce lag and pump.
     */

    // --- CHANNEL STATE (Lo-Fi vs Ambient) ---
    let currentChannel = 'lofi';
    let ambientEngine = null;
    let ambientInitialized = false;
    let ambientPlaying = false;
    let ambientSceneNames = { drift: 'MELODIC DRIFT', swell: 'HARMONIC SWELLS', rain: 'TEXTURE RAIN', deep: 'DEEP RESONANCE', bell: 'BELL TONES', pad: 'PAD SWELLS', phrase: 'MELODIC PHRASE', arpeggio: 'ARPEGGIO' };
    var ambientStartTime = 0;
    var ambientProgressInterval = null;
    let ambientMoodNames = { focus: 'Deep Focus', sleep: 'Drifting Sleep', ethereal: 'Ethereal Plane', dark: 'Void Space' };
    let currentAmbientMood = 'focus';
    let ambient24hInterval = null;
    let lofiEngine = null;
    let lofiInitialized = false;
    let lofiPlaying = false;
    var lofiDataArray = new Uint8Array(256);

    // --- 24H TIME LOGIC (same as Aether Radio — for Ambient channel) ---
    function get24hProgress() {
        var d = new Date();
        return (d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds() + d.getMilliseconds() / 1000) / (24 * 3600);
    }
    function getTimeOfDayColors(t24, moodR, moodG, moodB) {
        var dawn = Math.max(0, 1 - Math.abs(t24 - 0.2) * 8);
        var noon = Math.max(0, 1 - Math.abs(t24 - 0.5) * 6);
        var dusk = Math.max(0, 1 - Math.abs(t24 - 0.75) * 8);
        var night = Math.max(0, 1 - Math.min(t24 * 8, (1 - t24) * 8));
        var r = Math.round(120 * night + 255 * dawn + 255 * noon + 250 * dusk + moodR * 0.35);
        var g = Math.round(140 * night + 200 * dawn + 240 * noon + 180 * dusk + moodG * 0.35);
        var b = Math.round(180 * night + 240 * dawn + 255 * noon + 160 * dusk + moodB * 0.35);
        r = Math.min(255, Math.max(180, r));
        g = Math.min(255, Math.max(180, g));
        b = Math.min(255, Math.max(180, b));
        return { r: r, g: g, b: b };
    }

    // --- AMBIENT ENGINE (Aether-style Web Audio, no Tone.js) ---
    var AMBIENT_MOODS = {
        focus: { name: 'Morning Light', intervals: [0, 2, 4, 5, 7, 9, 11], root: 131, color: '255, 220, 180' },
        sleep: { name: 'Soft Sky', intervals: [0, 2, 4, 6, 7, 9, 11], root: 138.59, color: '180, 220, 255' },
        ethereal: { name: 'Golden Hour', intervals: [0, 2, 4, 5, 7, 9], root: 146.83, color: '255, 230, 160' },
        dark: { name: 'Warm Glow', intervals: [0, 2, 4, 5, 7, 9, 10], root: 130.81, color: '255, 200, 220' }
    };
    function AmbientEngine() {
        this.ctx = null;
        this.masterGain = null;
        this.compressor = null;
        this.analyser = null;
        this.reverbNode = null;
        this.delayNode = null;
        this.droneOsc1 = null;
        this.droneOsc2 = null;
        this.droneGain = null;
        this.textureNode = null;
        this.textureGain = null;
        this.melodyGain = null;
        this.isPlaying = false;
        this.currentMood = 'focus';
        this.generatedScale = [];
        this.schedulerTimer = null;
        this.currentScene = 'drift';
    }
    AmbientEngine.prototype.generateScale = function(moodKey) {
        var mood = AMBIENT_MOODS[moodKey];
        var root = mood.root;
        var notes = [];
        for (var oct = 0; oct < 4; oct++) {
            var baseFreq = root * Math.pow(2, oct);
            mood.intervals.forEach(function(interval) { notes.push(baseFreq * Math.pow(2, interval / 12)); });
        }
        return notes;
    };
    AmbientEngine.prototype.init = function() {
        var self = this;
        var AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.ratio.value = 12;
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 2048;
        this.analyser.smoothingTimeConstant = 0.85;
        this.compressor.connect(this.masterGain);
        this.masterGain.connect(this.analyser);
        this.analyser.connect(this.ctx.destination);
        this.reverbNode = null;
        var rate = this.ctx.sampleRate;
        var duration = 5;
        var decay = 4;
        var length = rate * duration;
        var impulse = this.ctx.createBuffer(2, length, rate);
        var left = impulse.getChannelData(0);
        var right = impulse.getChannelData(1);
        for (var i = 0; i < length; i++) {
            var env = Math.pow(1 - i / length, decay);
            left[i] = (Math.random() * 2 - 1) * env;
            right[i] = (Math.random() * 2 - 1) * env;
        }
        var convolver = this.ctx.createConvolver();
        convolver.buffer = impulse;
        this.reverbNode = convolver;
        this.delayNode = this.ctx.createDelay();
        this.delayNode.delayTime.value = 0.6;
        var delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.5;
        this.delayNode.connect(delayFeedback);
        delayFeedback.connect(this.delayNode);
        this.delayNode.connect(this.reverbNode);
        this.reverbNode.connect(this.compressor);
        this.melodyGain = this.ctx.createGain();
        this.melodyGain.gain.value = 0.6;
        this.melodyGain.connect(this.compressor);
        this.melodyGain.connect(this.delayNode);
        var melReverbSend = this.ctx.createGain();
        melReverbSend.gain.value = 0.6;
        this.melodyGain.connect(melReverbSend);
        melReverbSend.connect(this.reverbNode);
        this.droneGain = this.ctx.createGain();
        this.droneGain.gain.value = 0.4;
        this.droneGain.connect(this.reverbNode);
        this.droneGain.connect(this.compressor);
        this.textureGain = this.ctx.createGain();
        this.textureGain.gain.value = 0.05;
        this.textureGain.connect(this.compressor);
        return Promise.resolve();
    };
    AmbientEngine.prototype.start = function() {
        var self = this;
        if (!this.ctx) return this.init().then(function() { self.start(); });
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this.isPlaying = true;
        this.generatedScale = this.generateScale(this.currentMood);
        this.startDrone();
        this.startTexture();
        this.directorLoop();
    };
    AmbientEngine.prototype.stop = function() {
        this.isPlaying = false;
        var now = this.ctx ? this.ctx.currentTime : 0;
        if (this.droneOsc1) {
            this.droneGain.gain.setTargetAtTime(0, now, 1);
            this.droneOsc1.stop(now + 2);
            this.droneOsc2.stop(now + 2);
            this.droneOsc1 = null;
        }
        if (this.textureNode) {
            this.textureGain.gain.setTargetAtTime(0, now, 1);
            this.textureNode.stop(now + 2);
            this.textureNode = null;
        }
        clearTimeout(this.schedulerTimer);
    };
    AmbientEngine.prototype.directorLoop = function() {
        if (!this.isPlaying) return;
        if (Math.random() > 0.88) {
            var scenes = ['drift', 'drift', 'drift', 'swell', 'rain', 'bell', 'pad', 'phrase', 'arpeggio'];
            this.currentScene = scenes[Math.floor(Math.random() * scenes.length)];
        }
        var nextEventTime = 1400 + Math.random() * 2400;
        var self = this;
        switch (this.currentScene) {
            case 'swell': self.playChord(); nextEventTime = 4500 + Math.random() * 3500; break;
            case 'rain': self.playDroplet(); if (Math.random() < 0.35) self.playDroplet(); nextEventTime = 180 + Math.random() * 400; if (Math.random() > 0.96) this.currentScene = 'drift'; break;
            case 'bell': self.playBell(); nextEventTime = 2800 + Math.random() * 3200; break;
            case 'pad': self.playPadSwell(); nextEventTime = 8000 + Math.random() * 6000; break;
            case 'phrase': self.playMelodicPhrase(); nextEventTime = 3200 + Math.random() * 2600; break;
            case 'arpeggio': self.playArpeggio(); nextEventTime = 5000 + Math.random() * 4000; break;
            default: if (Math.random() < 0.4) self.playMelodicPhrase(); else self.playMelodicNote(); nextEventTime = 1600 + Math.random() * 2600; break;
        }
        this.schedulerTimer = setTimeout(function() { self.directorLoop(); }, nextEventTime);
    };
    AmbientEngine.prototype.playMelodicNote = function() {
        if (!this.isPlaying || !this.ctx) return;
        var scale = this.generatedScale.slice(4, 18);
        var idx = Math.floor(Math.random() * scale.length);
        var freq = scale[idx];
        var now = this.ctx.currentTime;
        var duration = 2.8 + Math.random() * 4;
        var osc = this.ctx.createOscillator();
        var modulator = this.ctx.createOscillator();
        var modGain = this.ctx.createGain();
        var filter = this.ctx.createBiquadFilter();
        var gain = this.ctx.createGain();
        var panner = this.ctx.createStereoPanner();
        osc.type = Math.random() > 0.7 ? 'triangle' : 'sine';
        modulator.frequency.value = freq * (0.25 + Math.random() * 0.25);
        modGain.gain.setValueAtTime(0, now);
        modGain.gain.linearRampToValueAtTime(freq * (1.2 + Math.random() * 1.5), now + duration * 0.3);
        modGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
        modulator.connect(modGain);
        modGain.connect(osc.frequency);
        filter.type = 'lowpass';
        filter.Q.value = 0.8 + Math.random() * 1.2;
        filter.frequency.setValueAtTime(freq * 1.2, now);
        filter.frequency.exponentialRampToValueAtTime(freq * (2.5 + Math.random() * 2), now + duration * 0.35);
        filter.frequency.exponentialRampToValueAtTime(freq * 1.5, now + duration);
        osc.frequency.value = freq;
        panner.pan.setValueAtTime((Math.random() * 1.2) - 0.6, now);
        panner.pan.linearRampToValueAtTime((Math.random() * 1.2) - 0.6, now + duration);
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.melodyGain);
        var peak = 0.06 + Math.random() * 0.08;
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(peak, now + 0.4 + Math.random() * 1.2);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        osc.start(now);
        modulator.start(now);
        osc.stop(now + duration + 1);
        modulator.stop(now + duration + 1);
    };
    AmbientEngine.prototype.playMelodicPhrase = function() {
        if (!this.isPlaying || !this.ctx) return;
        var scale = this.generatedScale.slice(5, 16);
        var len = 2 + Math.floor(Math.random() * 3);
        var step = Math.random() > 0.5 ? 1 : -1;
        var idx = Math.floor(Math.random() * (scale.length - len));
        var now = this.ctx.currentTime;
        for (var i = 0; i < len; i++) {
            var fi = idx + (step * i);
            if (fi < 0 || fi >= scale.length) break;
            var freq = scale[fi];
            var dur = 1.8 + Math.random() * 2.5;
            var osc = this.ctx.createOscillator();
            var gainNode = this.ctx.createGain();
            var filter = this.ctx.createBiquadFilter();
            var panner = this.ctx.createStereoPanner();
            osc.type = Math.random() > 0.6 ? 'sine' : 'triangle';
            osc.frequency.value = freq;
            filter.type = 'lowpass';
            filter.frequency.value = freq * (2 + Math.random() * 2);
            panner.pan.value = (Math.random() * 1.4) - 0.7;
            osc.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(panner);
            panner.connect(this.melodyGain);
            var t = now + i * (0.7 + Math.random() * 0.6);
            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(0.06 + Math.random() * 0.08, t + 0.2);
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + dur);
            osc.start(t);
            osc.stop(t + dur + 0.5);
        }
    };
    AmbientEngine.prototype.playBell = function() {
        if (!this.ctx) return;
        var scale = this.generatedScale.slice(14, 22);
        var freq = scale[Math.floor(Math.random() * scale.length)];
        var now = this.ctx.currentTime;
        var duration = 2 + Math.random() * 4;
        var osc = this.ctx.createOscillator();
        var osc2 = this.ctx.createOscillator();
        var gainNode = this.ctx.createGain();
        var filter = this.ctx.createBiquadFilter();
        var panner = this.ctx.createStereoPanner();
        osc.type = 'sine';
        osc.frequency.value = freq;
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2.4;
        filter.type = 'highpass';
        filter.frequency.value = freq * 0.5;
        filter.Q.value = 2;
        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(panner);
        panner.connect(this.melodyGain);
        panner.pan.value = (Math.random() * 1.2) - 0.6;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.04, now + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);
        osc.start(now);
        osc2.start(now);
        osc.stop(now + duration);
        osc2.stop(now + duration);
    };
    AmbientEngine.prototype.playPadSwell = function() {
        if (!this.ctx) return;
        var self = this;
        var startIdx = Math.floor(Math.random() * (self.generatedScale.length - 4));
        var indices = [startIdx, startIdx + 1, startIdx + 3];
        var now = self.ctx.currentTime;
        var duration = 12 + Math.random() * 8;
        indices.forEach(function(idx) {
            if (!self.generatedScale[idx]) return;
            var freq = self.generatedScale[idx];
            var osc = self.ctx.createOscillator();
            var gainNode = self.ctx.createGain();
            var filter = self.ctx.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = freq;
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            osc.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(self.melodyGain);
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.03 + Math.random() * 0.02, now + duration * 0.3);
            gainNode.gain.setValueAtTime(0.025, now + duration * 0.5);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            osc.start(now);
            osc.stop(now + duration + 0.5);
        });
    };
    AmbientEngine.prototype.playArpeggio = function() {
        if (!this.isPlaying || !this.ctx) return;
        var scale = this.generatedScale.slice(6, 14);
        var pattern = [0, 2, 4, 1, 3];
        var now = this.ctx.currentTime;
        var stepDur = 0.5 + Math.random() * 0.4;
        for (var i = 0; i < 5; i++) {
            var idx = pattern[i] % scale.length;
            var freq = scale[idx];
            var osc = this.ctx.createOscillator();
            var gainNode = this.ctx.createGain();
            var filter = this.ctx.createBiquadFilter();
            var panner = this.ctx.createStereoPanner();
            osc.type = Math.random() > 0.5 ? 'sine' : 'triangle';
            osc.frequency.value = freq;
            filter.type = 'lowpass';
            filter.frequency.value = freq * 3;
            osc.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(panner);
            panner.connect(this.melodyGain);
            panner.pan.value = (i / 5) * 1.2 - 0.6;
            var t = now + i * stepDur;
            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(0.05, t + 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + stepDur * 2);
            osc.start(t);
            osc.stop(t + stepDur * 2.5);
        }
    };
    AmbientEngine.prototype.playDroplet = function() {
        if (!this.ctx) return;
        var scale = this.generatedScale.slice(10);
        var freq = scale[Math.floor(Math.random() * scale.length)];
        var now = this.ctx.currentTime;
        var osc = this.ctx.createOscillator();
        var osc2 = this.ctx.createOscillator();
        var gain = this.ctx.createGain();
        var filter = this.ctx.createBiquadFilter();
        var panner = this.ctx.createStereoPanner();
        osc.type = 'sine';
        osc.frequency.value = freq;
        osc2.type = 'sine';
        osc2.frequency.value = freq * (1.5 + Math.random() * 0.5);
        filter.type = 'highpass';
        filter.frequency.setValueAtTime(freq * 0.4, now);
        filter.frequency.linearRampToValueAtTime(freq * 2.5, now + 0.08);
        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.melodyGain);
        panner.pan.value = (Math.random() * 1.8) - 0.9;
        var peak = 0.04 + Math.random() * 0.06;
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(peak, now + 0.008);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25 + Math.random() * 0.2);
        osc.start(now);
        osc2.start(now);
        osc.stop(now + 0.45);
        osc2.stop(now + 0.45);
    };
    AmbientEngine.prototype.playLowNote = function() {
        if (!this.ctx) return;
        var scale = this.generatedScale.slice(0, 6);
        var freq = scale[Math.floor(Math.random() * scale.length)];
        var now = this.ctx.currentTime;
        var duration = 5 + Math.random() * 4;
        var osc = this.ctx.createOscillator();
        var gain = this.ctx.createGain();
        var mod = this.ctx.createOscillator();
        var modGain = this.ctx.createGain();
        var filter = this.ctx.createBiquadFilter();
        mod.frequency.value = 0.08 + Math.random() * 0.06;
        modGain.gain.value = freq * 0.15;
        mod.connect(modGain);
        modGain.connect(osc.frequency);
        osc.type = Math.random() > 0.5 ? 'triangle' : 'sine';
        osc.frequency.value = freq;
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(120, now);
        filter.frequency.linearRampToValueAtTime(220 + Math.random() * 80, now + duration * 0.4);
        filter.frequency.linearRampToValueAtTime(140, now + duration);
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.2 + Math.random() * 0.15, now + 1.5 + Math.random() * 1);
        gain.gain.linearRampToValueAtTime(0, now + duration);
        osc.start(now);
        mod.start(now);
        osc.stop(now + duration + 1);
        mod.stop(now + duration + 1);
    };
    AmbientEngine.prototype.playChord = function() {
        if (!this.ctx) return;
        var startIdx = Math.floor(Math.random() * (this.generatedScale.length - 6));
        var voicings = [[0, 2, 4], [0, 2, 4, 5], [0, 1, 3, 5], [0, 2, 3, 5]];
        var indices = voicings[Math.floor(Math.random() * voicings.length)].map(function(o) { return startIdx + o; });
        var now = this.ctx.currentTime;
        var duration = 8 + Math.random() * 6;
        var self = this;
        indices.forEach(function(idx) {
            if (!self.generatedScale[idx]) return;
            var freq = self.generatedScale[idx];
            var osc = self.ctx.createOscillator();
            var gain = self.ctx.createGain();
            var panner = self.ctx.createStereoPanner();
            osc.type = Math.random() > 0.6 ? 'sawtooth' : 'triangle';
            osc.frequency.value = freq;
            osc.detune.value = (Math.random() * 12) - 6;
            var filter = self.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 0.5 + Math.random() * 1;
            filter.frequency.setValueAtTime(180 + Math.random() * 80, now);
            filter.frequency.linearRampToValueAtTime(600 + Math.random() * 400, now + duration * 0.35);
            filter.frequency.linearRampToValueAtTime(200, now + duration);
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(panner);
            panner.connect(self.reverbNode);
            panner.connect(self.masterGain);
            panner.pan.setValueAtTime(-0.6 + Math.random() * 0.4, now);
            panner.pan.linearRampToValueAtTime(0.6 - Math.random() * 0.4, now + duration);
            var peakGain = 0.03 + Math.random() * 0.03;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(peakGain, now + 2 + Math.random() * 2);
            gain.gain.linearRampToValueAtTime(0, now + duration);
            osc.start(now);
            osc.stop(now + duration + 1);
        });
    };
    AmbientEngine.prototype.startTexture = function() {
        if (this.textureNode || !this.ctx) return;
        var bufferSize = 2 * this.ctx.sampleRate;
        var noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        var output = noiseBuffer.getChannelData(0);
        var lastOut = 0;
        for (var i = 0; i < bufferSize; i++) {
            var white = Math.random() * 2 - 1;
            output[i] = (lastOut + (0.02 * white)) / 1.02;
            lastOut = output[i];
            output[i] *= 3.5;
        }
        var noise = this.ctx.createBufferSource();
        noise.buffer = noiseBuffer;
        noise.loop = true;
        var filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        noise.connect(filter);
        filter.connect(this.textureGain);
        noise.start();
        this.textureNode = noise;
    };
    AmbientEngine.prototype.startDrone = function() {
        if (this.droneOsc1 || !this.ctx) return;
        var mood = AMBIENT_MOODS[this.currentMood];
        var osc1 = this.ctx.createOscillator();
        var osc2 = this.ctx.createOscillator();
        var osc3 = this.ctx.createOscillator();
        var filter = this.ctx.createBiquadFilter();
        osc1.type = 'triangle';
        osc1.frequency.value = mood.root;
        osc2.type = 'sine';
        osc2.frequency.value = mood.root * 1.005;
        osc3.type = 'sine';
        osc3.frequency.value = mood.root * 0.5;
        osc3.connect(this.droneGain);
        var lfo = this.ctx.createOscillator();
        lfo.frequency.value = 0.035 + Math.random() * 0.025;
        var lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 100;
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        lfo.start();
        filter.type = 'lowpass';
        filter.frequency.value = 150 + Math.random() * 80;
        filter.Q.value = 0.8;
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(this.droneGain);
        osc1.start();
        osc2.start();
        osc3.start();
        this.droneOsc1 = osc1;
        this.droneOsc2 = osc2;
    };
    AmbientEngine.prototype.setMood = function(moodKey) {
        this.currentMood = moodKey;
        this.generatedScale = this.generateScale(moodKey);
        if (this.isPlaying && this.droneOsc1) {
            var now = this.ctx.currentTime;
            var root = AMBIENT_MOODS[moodKey].root;
            this.droneOsc1.frequency.exponentialRampToValueAtTime(root, now + 4);
            this.droneOsc2.frequency.exponentialRampToValueAtTime(root * 1.01, now + 4);
        }
    };
    AmbientEngine.prototype.getAnalyserData = function(array) {
        if (this.analyser) this.analyser.getByteFrequencyData(array);
    };

    // --- NOTE / DURATION HELPERS (for LofiEngine — no Tone dependency) ---
    var NOTE_TO_MIDI = { C: 0, 'C#': 1, Db: 1, D: 2, 'D#': 3, Eb: 3, E: 4, F: 5, 'F#': 6, Gb: 6, G: 7, 'G#': 8, Ab: 8, A: 9, 'A#': 10, Bb: 10, B: 11 };
    function noteNameToMidi(noteName) {
        var m = noteName.match(/^([A-G][b#]?)(\d+)$/);
        if (!m) return 60;
        var semis = NOTE_TO_MIDI[m[1]] || 0;
        var oct = parseInt(m[2], 10);
        return (oct + 1) * 12 + semis;
    }
    function midiToFreq(midi) { return 440 * Math.pow(2, (midi - 69) / 12); }
    function noteToFreq(noteName) { return midiToFreq(noteNameToMidi(noteName)); }
    function durationToSeconds(durStr, bpm) {
        var beatSec = 60 / bpm;
        if (durStr === '1n') return beatSec * 4;
        if (durStr === '2n') return beatSec * 2;
        if (durStr === '4n') return beatSec;
        if (durStr === '8n') return beatSec / 2;
        if (durStr === '16n') return beatSec / 4;
        if (durStr === '32n') return beatSec / 8;
        if (durStr === '64n') return beatSec / 16;
        if (durStr === '1m') return beatSec * 4 * 4;
        return beatSec / 4;
    }

    // --- LOFI ENGINE (same sound-making as Ambient: raw Web Audio, no Tone, setTimeout loop) ---
    function LofiEngine() {
        this.ctx = null;
        this.masterGain = null;
        this.compressor = null;
        this.analyser = null;
        this.reverbNode = null;
        this.delayNode = null;
        this.melodyGain = null;
        this.drumGain = null;
        this.bassGain = null;
        this.isPlaying = false;
        this.stepTimer = null;
        this.step = 0;
        this.nextStepTime = 0;
    }
    LofiEngine.prototype.init = function() {
        var AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.ratio.value = 8;
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 2048;
        this.analyser.smoothingTimeConstant = 0.85;
        this.compressor.connect(this.masterGain);
        this.masterGain.connect(this.analyser);
        this.analyser.connect(this.ctx.destination);
        var rate = this.ctx.sampleRate;
        var length = rate * 4;
        var impulse = this.ctx.createBuffer(2, length, rate);
        var left = impulse.getChannelData(0), right = impulse.getChannelData(1);
        for (var i = 0; i < length; i++) {
            var env = Math.pow(1 - i / length, 3);
            left[i] = (Math.random() * 2 - 1) * env;
            right[i] = (Math.random() * 2 - 1) * env;
        }
        var convolver = this.ctx.createConvolver();
        convolver.buffer = impulse;
        this.reverbNode = convolver;
        this.delayNode = this.ctx.createDelay();
        this.delayNode.delayTime.value = 0.4;
        var delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.4;
        this.delayNode.connect(delayFeedback);
        delayFeedback.connect(this.delayNode);
        this.delayNode.connect(this.reverbNode);
        this.reverbNode.connect(this.compressor);
        this.melodyGain = this.ctx.createGain();
        this.melodyGain.gain.value = 0.55;
        this.melodyGain.connect(this.compressor);
        this.melodyGain.connect(this.delayNode);
        this.drumGain = this.ctx.createGain();
        this.drumGain.gain.value = 0.65;
        this.drumGain.connect(this.compressor);
        this.bassGain = this.ctx.createGain();
        this.bassGain.gain.value = 0.6;
        this.bassGain.connect(this.compressor);
        return Promise.resolve();
    };
    LofiEngine.prototype.playKick = function(time, vel) {
        if (!this.ctx) return;
        var osc = this.ctx.createOscillator();
        var gain = this.ctx.createGain();
        var filter = this.ctx.createBiquadFilter();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(40, time + 0.08);
        osc.frequency.exponentialRampToValueAtTime(32, time + 0.35);
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.drumGain);
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(vel * 0.9, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.35);
        osc.start(time);
        osc.stop(time + 0.4);
    };
    LofiEngine.prototype.playSnare = function(time, vel) {
        if (!this.ctx) return;
        var bufferSize = this.ctx.sampleRate * 0.15;
        var buf = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        var data = buf.getChannelData(0);
        for (var i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
        var noise = this.ctx.createBufferSource();
        noise.buffer = buf;
        var filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 800;
        var gain = this.ctx.createGain();
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.drumGain);
        gain.gain.setValueAtTime(vel * 0.5, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.12);
        noise.start(time);
        noise.stop(time + 0.15);
    };
    LofiEngine.prototype.playHihat = function(time, vel, decaySec, freq) {
        if (!this.ctx) return;
        var bufferSize = Math.max(512, this.ctx.sampleRate * decaySec);
        var buf = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        var data = buf.getChannelData(0);
        for (var i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
        var noise = this.ctx.createBufferSource();
        noise.buffer = buf;
        var filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = freq || 160;
        filter.Q.value = 1;
        var gain = this.ctx.createGain();
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.drumGain);
        gain.gain.setValueAtTime(vel * 0.4, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + decaySec);
        noise.start(time);
        noise.stop(time + decaySec);
    };
    LofiEngine.prototype.playBass = function(time, freq, durSec, vel) {
        if (!this.ctx) return;
        var osc = this.ctx.createOscillator();
        var gain = this.ctx.createGain();
        var filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        osc.type = 'sine';
        osc.frequency.value = freq;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.bassGain);
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(vel * 0.5, time + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, time + durSec);
        osc.start(time);
        osc.stop(time + durSec + 0.1);
    };
    LofiEngine.prototype.playPianoChord = function(time, noteNames, durSec, vel) {
        if (!this.ctx) return;
        var self = this;
        noteNames.forEach(function(n) {
            var freq = noteToFreq(n);
            var osc = self.ctx.createOscillator();
            var mod = self.ctx.createOscillator();
            var modGain = self.ctx.createGain();
            var gain = self.ctx.createGain();
            var filter = self.ctx.createBiquadFilter();
            mod.type = 'sine';
            mod.frequency.value = freq * 2.8;
            modGain.gain.value = freq * 0.4;
            mod.connect(modGain);
            modGain.connect(osc.frequency);
            osc.type = 'sine';
            osc.frequency.value = freq;
            filter.type = 'lowpass';
            filter.frequency.value = 2000;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(self.melodyGain);
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(vel * 0.12, time + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, time + durSec);
            osc.start(time);
            mod.start(time);
            osc.stop(time + durSec + 0.1);
            mod.stop(time + durSec + 0.1);
        });
    };
    LofiEngine.prototype.playAccordion = function(time, noteNames, durSec, vel) {
        if (!this.ctx) return;
        var self = this;
        noteNames.slice(0, 3).forEach(function(n) {
            var freq = noteToFreq(n);
            var osc = self.ctx.createOscillator();
            var mod = self.ctx.createOscillator();
            var modGain = self.ctx.createGain();
            var gain = self.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            mod.type = 'sine';
            mod.frequency.value = freq * 2;
            modGain.gain.value = 0.3;
            mod.connect(modGain);
            modGain.connect(osc.frequency);
            osc.connect(gain);
            gain.connect(self.melodyGain);
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(vel * 0.1, time + 0.1);
            gain.gain.linearRampToValueAtTime(0, time + durSec);
            osc.start(time);
            mod.start(time);
            osc.stop(time + durSec + 0.1);
            mod.stop(time + durSec + 0.1);
        });
    };
    LofiEngine.prototype.playLead = function(time, noteName, durSec, vel) {
        if (!this.ctx) return;
        var freq = noteToFreq(noteName);
        var osc = this.ctx.createOscillator();
        var gain = this.ctx.createGain();
        var filter = this.ctx.createBiquadFilter();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        filter.type = 'lowpass';
        filter.frequency.value = freq * 2;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.melodyGain);
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(vel * 0.15, time + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.001, time + durSec);
        osc.start(time);
        osc.stop(time + durSec + 0.1);
    };
    LofiEngine.prototype.playBell = function(time, noteName, durSec, vel) {
        if (!this.ctx) return;
        var freq = noteToFreq(noteName);
        var osc = this.ctx.createOscillator();
        var osc2 = this.ctx.createOscillator();
        var gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2.5;
        osc.connect(gain);
        osc2.connect(gain);
        gain.connect(this.melodyGain);
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(vel * 0.028, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + durSec);
        osc.start(time);
        osc2.start(time);
        osc.stop(time + durSec);
        osc2.stop(time + durSec);
    };
    LofiEngine.prototype.playPad = function(time, noteNames, durSec, vel) {
        if (!this.ctx) return;
        var self = this;
        noteNames.slice(0, 3).forEach(function(n) {
            var freq = noteToFreq(n);
            var osc = self.ctx.createOscillator();
            var gain = self.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(self.melodyGain);
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(vel * 0.06, time + 1);
            gain.gain.linearRampToValueAtTime(0, time + durSec);
            osc.start(time);
            osc.stop(time + durSec + 0.5);
        });
    };
    LofiEngine.prototype.playArp = function(time, noteName, durSec, vel) {
        if (!this.ctx) return;
        var freq = noteToFreq(noteName);
        var osc = this.ctx.createOscillator();
        var gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(this.melodyGain);
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(vel * 0.08, time + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, time + durSec);
        osc.start(time);
        osc.stop(time + durSec);
    };
    LofiEngine.prototype.getAnalyserData = function(array) {
        if (this.analyser) this.analyser.getByteFrequencyData(array);
    };
    LofiEngine.prototype.stop = function() {
        this.isPlaying = false;
        if (this.stepTimer) clearTimeout(this.stepTimer);
        this.stepTimer = null;
    };
    LofiEngine.prototype.start = function() {
        var self = this;
        if (!this.ctx) return this.init().then(function() { self.start(); });
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this.isPlaying = true;
        this.step = 0;
        this.stepLoop();
    };
    LofiEngine.prototype.stepLoop = function() {
        if (!this.isPlaying || !this.ctx || typeof state === 'undefined' || !state.scale || !state.scale.length) return;
        var self = this;
        var stepsPerBar = state.stepsPerBar || 16;
        var totalCycleBars = state.totalCycleBars || 16;
        var bpm = state.bpm || 75;
        var stepDurationSec = (60 / bpm) / 4;
        var patIdx = this.step % stepsPerBar;
        var sixteenth = this.step % 4;
        var t = this.ctx.currentTime;
        var seed = state.currentSeed + 77777 + (state.barCount * stepsPerBar + patIdx) * 31;
        var seqRNG = mulberry32(seed >>> 0);
        var swingOffset = (state.params && state.params.swing || 0) * (sixteenth % 2 === 1 ? 1 : 0);
        var humanize = (seqRNG() - 0.5) * 0.02;
        t += swingOffset / 1000 + humanize;
        var isIntro = state.section === 'Intro';
        var isVerse = state.section === 'Verse';
        var isChorus = state.section === 'Chorus';
        var isClimax = state.section === 'Climax';
        var isBreakdown = state.section === 'Breakdown';
        var progIdx = state.barCount % 4;
        var useBridge = state.bridgeProgression && state.barCount >= (state.bridgeStartBar || 0);
        var progression = useBridge ? state.bridgeProgression : state.progression;
        var degree = isBreakdown ? (state.breakdownChordDegree != null ? state.breakdownChordDegree : state.progression[0]) : progression[progIdx];
        var rawNotes = getChord(degree, state.scale, 4, state.useSeventh);
        var notes = (typeof voiceLead === 'function') ? voiceLead(rawNotes, state.lastChordVoicing) : rawNotes;
        var dur = function(str) { return durationToSeconds(str, bpm); };

        if (this.step % stepsPerBar === 0) state.lastChordVoicing = notes;

        var effPattern = isIntro && state.pianoPatternIntro && state.pianoPatternIntro.length ? state.pianoPatternIntro
            : isBreakdown && state.pianoPatternBreakdown && state.pianoPatternBreakdown.length ? state.pianoPatternBreakdown
            : (state.pianoUseBarAlternation && state.pianoPatternAlt && state.pianoPatternAlt.length && (state.barCount % 2 === 1)) ? state.pianoPatternAlt
            : state.pianoPattern;
        var pianoVal = effPattern && effPattern[patIdx] ? effPattern[patIdx] : 0;
        var effectiveDensity = isVerse ? (state.pianoDensity || 0.85) * 0.72 : (state.pianoDensity || 0.85);
        var passDensity = pianoVal > 0 && (isBreakdown ? seqRNG() < 0.28 : seqRNG() < effectiveDensity);
        if (pianoVal > 0 && (!isBreakdown || (state.pianoPatternBreakdown && state.pianoPatternBreakdown.length)) && passDensity) {
            if (pianoVal === 1) {
                var chordDur = state.pianoChordDurations ? state.pianoChordDurations[Math.floor(seqRNG() * state.pianoChordDurations.length)] : '4n';
                self.playPianoChord(t, notes, dur(chordDur), 0.5 + seqRNG() * 0.2);
            } else if (pianoVal === 2) {
                var dyad = [notes[0], notes[2]];
                var dyadDur = (state.pianoDyadDurations || ['8n'])[Math.floor(seqRNG() * (state.pianoDyadDurations || ['8n']).length)];
                self.playPianoChord(t, dyad, dur(dyadDur), 0.4 + seqRNG() * 0.15);
            } else if (pianoVal === 3 || pianoVal === 5) {
                var noteIdx = pianoVal === 3 ? (Math.floor(patIdx / 2) % notes.length) : Math.min(2, notes.length - 1);
                var arpDur = (state.pianoArpDurations || ['8n'])[Math.floor(seqRNG() * (state.pianoArpDurations || ['8n']).length)];
                self.playPianoChord(t, [notes[noteIdx]], dur(arpDur), 0.35 + seqRNG() * 0.1);
            } else if (pianoVal === 4 && notes[0]) {
                var octNote = notes[0].replace(/(\d+)$/, function(_, o) { return (parseInt(o, 10) + 1) + ''; });
                self.playPianoChord(t, [notes[0], octNote], dur((state.pianoOctaveDurations || ['4n'])[0] || '4n'), 0.4 + seqRNG() * 0.1);
            }
        }

        var accVal = state.accordionPattern && state.accordionPattern[patIdx];
        if (accVal > 0 && !isIntro && (isBreakdown || isVerse || isClimax || (isChorus && seqRNG() < 0.3))) {
            var accNotes = getChord(degree, state.scale, 3, state.useSeventh);
            var accVoiced = (typeof voiceLead === 'function') ? voiceLead(accNotes, state.lastChordVoicing) : accNotes;
            if (accVal === 1) {
                var accChordDur = (state.accordionChordDurations || ['2n'])[Math.floor(seqRNG() * (state.accordionChordDurations || ['2n']).length)];
                self.playAccordion(t, accVoiced.slice(0, 3), dur(accChordDur), 0.12 + seqRNG() * 0.08);
            } else if (accVal === 3) {
                var arpNote = accVoiced[Math.floor(patIdx / 4) % accVoiced.length];
                var accArpDur = (state.accordionArpDurations || ['4n'])[Math.floor(seqRNG() * (state.accordionArpDurations || ['4n']).length)];
                self.playAccordion(t, [arpNote], dur(accArpDur), 0.1 + seqRNG() * 0.06);
            }
        }

        if (!isIntro && state.bassPattern && state.bassPattern[patIdx] > 0) {
            var bassChord = getChord(degree, state.scale, 3, state.useSeventh);
            var bassNote = null;
            var bpVal = state.bassPattern[patIdx];
            if (bpVal === 1) bassNote = bassChord[0];
            else if (bpVal === 3) bassNote = bassChord[1];
            else if (bpVal === 5) bassNote = bassChord[2];
            else if (bpVal === 7) {
                var nextDeg = isBreakdown ? (state.breakdownChordDegree != null ? state.breakdownChordDegree : state.progression[0]) : state.progression[(state.barCount + 1) % 4];
                bassNote = getChord(nextDeg, state.scale, 3, false)[0];
            }
            if (bassNote) {
                var bassVel = isClimax ? 0.65 : isBreakdown ? 0.3 : 0.5;
                var bassDurStr = state.bassDurations ? state.bassDurations[Math.floor(seqRNG() * state.bassDurations.length)] : '8n';
                self.playBass(t, noteToFreq(bassNote), dur(bassDurStr), bassVel);
            }
        }

        var config = typeof STYLES !== 'undefined' && state.style && STYLES[state.style] ? STYLES[state.style] : {};
        if (config.hasLead && !isIntro && !isBreakdown && (state.leadStepMod === 0 && patIdx % 8 === 0 || (state.leadStepMod === 1 && patIdx % 8 === 0 && (patIdx + state.barCount) % 2 === 0)) && seqRNG() < (isClimax ? 0.38 : isChorus ? 0.2 : 0.08)) {
            var leadChord = getChord(degree, state.scale, 5, state.useSeventh);
            var motifIdx = (Math.floor(patIdx / 8) + state.barCount) % (state.trackMotif && state.trackMotif.length ? state.trackMotif.length : 8);
            var leadNote = (state.trackMotif && state.trackMotif[motifIdx]) ? state.trackMotif[motifIdx] : leadChord[motifIdx % leadChord.length];
            if (leadNote) {
                var leadDurStr = (state.leadDurations || ['8n'])[Math.floor(seqRNG() * (state.leadDurations || ['8n']).length)];
                self.playLead(t, leadNote, dur(leadDurStr), 0.15 + seqRNG() * 0.08);
            }
        }

        if (!isIntro && !isBreakdown && state.bellProb > 0 && (patIdx % 8 === 4 || patIdx % 8 === 6) && seqRNG() < state.bellProb) {
            var bellChord = getChord(degree, state.scale, 5, state.useSeventh);
            var bellNote = (state.trackMotif && state.trackMotif[Math.floor(patIdx / 4) % (state.trackMotif.length || 8)]) || bellChord[Math.floor(seqRNG() * bellChord.length)];
            if (bellNote) {
                var bellDurStr = (state.bellDurations || state.leadDurations || ['8n'])[Math.floor(seqRNG() * (state.bellDurations || ['8n']).length)];
                self.playBell(t, bellNote, dur(bellDurStr), 0.04 + seqRNG() * 0.03);
            }
        }

        if (!isIntro && !isBreakdown && state.drumPattern && state.drumPattern[patIdx] === 1) {
            var kickVel = 0.7 + seqRNG() * 0.2 + (patIdx === 0 ? 0.1 : 0) + (isClimax ? 0.15 : 0);
            self.playKick(t, Math.min(0.95, kickVel));
        }
        if (!isIntro && !isBreakdown && state.drumPattern && state.drumPattern[patIdx] === 2 && (isVerse ? seqRNG() > 0.45 : true)) {
            self.playSnare(t, Math.min(0.95, 0.55 + seqRNG() * 0.2 + (isClimax ? 0.12 : 0)));
        }
        if (!isIntro && !isBreakdown && state.hihatPattern && state.hihatPattern[patIdx] > 0) {
            var hhVal = state.hihatPattern[patIdx];
            var hhFreq = 140 + seqRNG() * 60;
            if (hhVal === 1) self.playHihat(t, 0.2 + seqRNG() * 0.1, 0.04, hhFreq);
            else if (hhVal === 2) self.playHihat(t, 0.06, 0.02, 120 + seqRNG() * 30);
            else if (hhVal === 3) self.playHihat(t, 0.25 + seqRNG() * 0.1, 0.07, 170 + seqRNG() * 50);
            else if (hhVal === 4) self.playHihat(t, 0.3 + seqRNG() * 0.1, 0.04, 180 + seqRNG() * 40);
        }
        if (isBreakdown && (patIdx === 0 || patIdx === Math.floor(stepsPerBar / 2))) {
            self.playKick(t, 0.25 + seqRNG() * 0.1);
        }
        if (isBreakdown && (patIdx === Math.floor(stepsPerBar / 4) || patIdx === Math.floor(stepsPerBar * 0.75))) {
            self.playSnare(t, 0.1 + seqRNG() * 0.06);
        }

        this.step = (this.step + 1) % stepsPerBar;
        if (this.step === 0) {
            state.barCount++;
            if (state.barCount < 4) state.section = 'Intro';
            else {
                var cycleBar = (state.barCount - 4) % totalCycleBars;
                var order = state.sectionOrder || ['Verse', 'Chorus', 'Climax', 'Breakdown'];
                var lengths = state.sectionLengths || [4, 4, 4, 4];
                var acc = 0;
                for (var i = 0; i < order.length; i++) {
                    if (cycleBar < acc + lengths[i]) { state.section = order[i]; break; }
                    acc += lengths[i];
                }
            }
        }

        var nextDelayMs = (stepDurationSec + swingOffset / 1000 + (seqRNG() - 0.5) * 0.012) * 1000;
        this.stepTimer = setTimeout(function() { self.stepLoop(); }, Math.max(1, nextDelayMs));
    };

    function mulberry32(a) {
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }

    const MIN_TRACK_MS = 95 * 1000; 
    const MAX_TRACK_MS = 180 * 1000;
    
    let currentRNG = null; 
    let isTransitioning = false;
    let isInitializing = false; 

    // --- METADATA (expanded for more variety so tracks feel less samey) ---
    const TITLES_A = ["Sun", "Urban", "Funky", "Cosmic", "Sunday", "Coffee", "Neon", "Late", "Golden", "Floating", "Velvet", "Soft", "Early", "Dusk", "Blue", "Warm", "Low", "Breeze", "Mellow", "Calm", "Quiet", "Night", "Clear", "Fading"];
    const TITLES_B = ["Dreams", "Day", "Loop", "Groove", "Thoughts", "Vibes", "Window", "Clouds", "Station", "Memories", "Soul", "Waves", "Pages", "Lights", "Hours", "Side", "Tape", "Room", "Sky", "Mood", "Beat", "Morning", "Glow", "Light"];
    const ARTISTS_A = ["Lo-Fi", "Chill", "Beats", "Bedroom", "Analog", "Digital", "Sleepy", "Mellow", "Jazz", "Retro", "Lazy", "Quiet", "Soft", "Deep", "Warm", "Cosmic", "Nostalgic", "Urban", "Velvet", "Blue", "Golden", "Stardust"];
    const ARTISTS_B = ["Boy", "Girl", "Project", "Collective", "Hop", "Cat", "Smith", "Waves", "FM", "Tapes", "Corner", "Society", "Lab", "Room", "Band", "Radio", "Sounds", "Beats", "Crew", "Studio", "Arcade", "Café", "Lounge", "Atelier"];

    // --- CONFIG ---
    const NOTES = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'];
    // Modes biased toward minor/Dorian for a more mature, jazzy lo-fi feel (less nursery/bright)
    const MOOD_SCALES = { 'Chill': ['Dorian', 'Minor', 'Phrygian'], 'Uplifting': ['Major', 'Lydian'], 'Groovy': ['Dorian', 'Minor', 'Mixolydian'], 'Dreamy': ['Dorian', 'Minor', 'Lydian'], 'Warm': ['Minor', 'Dorian', 'Mixolydian'] };
    const MODES = { 'Minor': [0, 2, 3, 5, 7, 8, 10], 'Dorian': [0, 2, 3, 5, 7, 9, 10], 'Major': [0, 2, 4, 5, 7, 9, 11], 'Lydian': [0, 2, 4, 6, 7, 9, 11], 'Phrygian': [0, 1, 3, 5, 7, 8, 10], 'Mixolydian': [0, 2, 4, 5, 7, 9, 10] };

    // --- TIME SIGNATURES --- 4/4 (16 steps), 3/4 (12 steps), 6/8 (12 steps, triplet feel)
    const TIME_SIGNATURES = {
        '4/4': { stepsPerBar: 16, transportInterval: '16n' },
        '3/4': { stepsPerBar: 12, transportInterval: '16n' },
        '6/8': { stepsPerBar: 12, transportInterval: '16n' }
    };

    // --- Lo-fi hip-hop drum patterns. 1=kick, 2=snare, 0=rest. (16 iconic patterns)
    const DRUM_LOOPS = {
        'BoomBap':    [1,0,0,1, 2,0,0,0, 0,1,0,0, 2,0,0,0],
        'BoomBap2':   [1,0,0,0, 2,0,1,0, 0,0,0,0, 2,0,0,1],  // Syncopated kick on &3
        'Dilla':      [1,0,0,0, 2,0,0,1, 0,0,1,0, 2,0,0,0],
        'DillaSwing': [0,0,1,0, 2,0,0,0, 0,1,0,0, 2,0,0,1],  // Late kick — drunk feel
        'Lofi':       [1,0,0,1, 2,0,0,0, 1,0,0,0, 2,0,0,0],
        'LofiHeavy':  [1,0,1,0, 2,0,0,1, 1,0,0,0, 2,0,1,0],  // Busier, more kick energy
        'ChillHop':   [1,0,0,0, 2,0,0,0, 0,1,0,0, 2,0,0,1],
        'JazzHop':    [1,0,0,1, 2,0,0,0, 0,1,0,0, 2,0,0,1],
        'Backbeat':   [1,0,0,0, 2,0,0,0, 1,0,0,0, 2,0,0,0],
        'Shuffle':    [1,0,0,1, 2,0,0,0, 1,0,0,1, 2,0,0,0],  // Double kick shuffle
        'Trap':       [1,0,0,0, 0,0,2,0, 0,0,1,0, 2,0,0,0],  // Trap-influenced offbeat snare
        'NeoSoul':    [1,0,0,0, 2,0,0,0, 0,0,1,0, 0,2,0,0],  // Ghost kick, late snare
        'Pocket':     [1,0,0,0, 2,0,0,1, 0,0,0,0, 2,0,0,0],  // Tight pocket — less is more
        'Swing':      [1,0,0,0, 2,0,0,0, 0,0,1,0, 2,0,1,0],  // Swing kick on &4
        'Broken':     [1,0,1,0, 0,0,2,0, 1,0,0,0, 0,2,0,0],  // Broken beat — unpredictable
        'HalfTime':   [1,0,0,0, 0,0,0,0, 2,0,0,0, 0,0,0,0],  // Half-time — spacious
    };
    // --- 3/4 & 6/8 DRUM PATTERNS (12-step, waltz / compound feel)
    const DRUM_LOOPS_34 = {
        'Waltz':      [1,0,0,0, 2,0,0,0, 0,0,1,0],
        'WaltzBap':   [1,0,0,0, 0,2,0,0, 1,0,0,0],
        'SixEight':   [1,0,0,0, 2,0,0,0, 0,1,0,0],
        'Triplet':    [1,0,0,0, 0,0,2,0, 0,1,0,0],
        'Sparse34':   [1,0,0,0, 0,0,0,0, 2,0,0,0],
    };
    // Style-consistent drum–bass pairing: kick and bass lock to same pocket (trip hop = deep, sparse)
    const DRUM_BASS_PAIRS = {
        'Dilla': ['DillaSub', 'LazyGroove', 'BoomBapSub'], 'DillaSwing': ['DillaSub', 'LazyGroove'],
        'BoomBap': ['BoomBapSub', 'DeepRoot', 'GrooveSub'], 'BoomBap2': ['BoomBapSub', 'GrooveSub'],
        'NeoSoul': ['NeoSoul', 'DillaSub', 'RnBSub', 'SoulWalk'], 'ChillHop': ['ChillSub', 'DeepRoot', 'DillaSub'],
        'JazzHop': ['JazzWalk', 'SoulWalk', 'DillaSub'], 'Lofi': ['DeepRoot', 'SubHold', 'ChillSub'],
        'LofiHeavy': ['BoomBapSub', 'GrooveSub', 'Pulse'], 'Backbeat': ['DeepRoot', 'Pulse', 'RootFifth'],
        'Trap': ['GrooveSub', 'RnBSub'], 'Pocket': ['DillaSub', 'DeepRoot'], 'HalfTime': ['SubHold', 'Heartbeat', 'DeepRoot'],
        'Broken': ['LazyGroove', 'GentleWalk', 'DillaSub'], 'Shuffle': ['ChillSub', 'Bounce'],
        'Swing': ['DillaSub', 'GrooveSub']
    };
    // --- DEEP LO-FI BASS LINES. Root-focused patterns that lock with the kick and anchor the chord.
    // Values: 0=rest, 1=chord root, 3=chord 3rd, 5=chord 5th, 7=approach (next chord root).
    // Deep sub bass needs SPACE — fewer notes, longer rests, root on beat 1. (16-step = 1 bar)
    const BASS_PATTERNS = {
        // --- DEEP & MINIMAL (anchor patterns — bass sits on root, gives space to piano)
        'DeepRoot':    [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],  // Root on 1 and 3 — classic lo-fi anchor
        'SubHold':     [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],  // One long root per bar — ultra minimal
        'Heartbeat':   [1,0,0,0, 0,0,0,0, 0,0,0,0, 1,0,0,0],  // Root on 1 and 4 — heartbeat feel
        'Pulse':       [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],  // Quarter-note root pulse — driving but deep
        // --- ROOT + FIFTH (harmonic anchoring — outlines the chord with bass and piano together)
        'RootFifth':   [1,0,0,0, 0,0,0,0, 5,0,0,0, 0,0,0,0],  // Root then 5th — strong harmonic frame
        'FifthDown':   [5,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],  // 5th then root — inverted motion
        'ChillSub':    [1,0,0,0, 5,0,0,0, 1,0,0,0, 5,0,0,0],  // Alternating root-5th — gentle rocking
        // --- GROOVE (syncopated root patterns — lock with Dilla/boom-bap kick)
        'GrooveSub':   [1,0,0,0, 0,0,5,0, 1,0,0,0, 0,0,0,0],  // Syncopated 5th anticipation
        'DillaSub':    [1,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,5,0],  // Dilla pocket — late hits
        'BoomBapSub':  [1,0,0,1, 0,0,0,0, 0,1,0,0, 0,0,0,0],  // Boom-bap kick-locked bass
        'LazyGroove':  [0,0,1,0, 0,0,0,0, 0,0,1,0, 0,0,0,0],  // Behind-the-beat feel
        // --- WALKING (chord-tone movement — matches piano chord changes)
        'SoftWalk':    [1,0,0,0, 3,0,0,0, 5,0,0,0, 7,0,0,0],  // Root→3rd→5th→approach
        'JazzWalk':    [1,0,0,0, 5,0,0,0, 3,0,0,0, 7,0,0,0],  // Root→5th→3rd→approach
        'SoulWalk':    [1,0,0,0, 3,0,0,0, 1,0,0,0, 5,0,0,0],  // Root-3rd-root-5th — soulful
        'GentleWalk':  [1,0,0,0, 0,0,3,0, 5,0,0,0, 0,0,7,0],  // Sparse walking with rests
        // --- BOUNCE (rhythmic variation — pairs with syncopated piano comping)
        'Bounce':      [1,0,0,1, 0,0,0,0, 5,0,0,0, 0,0,0,0],  // Octave bounce then 5th
        'SlowBounce':  [1,0,0,0, 0,0,1,0, 0,0,0,0, 5,0,0,0],  // Gentle syncopated bounce
        'RnBSub':      [1,0,0,0, 0,0,3,0, 5,0,0,0, 0,0,0,0],  // R&B pocket — root, late 3rd, 5th
        'NeoSoul':     [1,0,0,0, 0,0,0,0, 3,0,0,0, 0,0,7,0],  // Neo-soul approach — root, 3rd, walk to next
    };
    const BASS_PATTERNS_34 = {
        'WaltzRoot':   [1,0,0,0, 0,0,0,0, 1,0,0,0],
        'WaltzWalk':   [1,0,0,0, 3,0,0,0, 5,0,0,0],
        'Pulse34':     [1,0,0,0, 1,0,0,0, 1,0,0,0],
        'SixEight':    [1,0,0,0, 0,0,5,0, 1,0,0,0],
    };
    // --- LOFI PIANO PATTERNS. 0=rest, 1=full chord, 2=dyad, 3=arpeggio note, 4=octave, 5=passing (16-step)
    // Piano is the melodic lead — patterns complement deep bass. Hash-driven variety: density, section, alternation.
    const PIANO_PATTERNS = {
        // --- BLOCK CHORDS (pairs with deep root-only bass patterns)
        'Block':       [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],  // Two chords per bar — classic lo-fi
        'BlockSlow':   [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],  // One chord per bar — maximum space
        'RhodesHit':   [1,0,0,0, 0,0,0,0, 0,0,1,0, 0,0,0,1],  // Soulful laid-back Rhodes feel
        'OffbeatChord':[0,0,1,0, 0,0,0,0, 0,0,1,0, 0,0,0,0],  // Backbeat — sits between bass hits
        // --- COMPING (jazzy rhythmic hits)
        'Comping':     [1,0,0,0, 0,0,1,0, 0,0,0,0, 0,1,0,0],  // Jazz comping — syncopated stabs
        'NeoSoulComp': [0,0,1,0, 0,0,0,1, 0,0,0,0, 1,0,0,0],  // Neo-soul pocket — behind the beat
        'Bounce':      [1,0,0,1, 0,0,0,0, 1,0,0,0, 0,0,1,0],  // Bouncy — hits lock with bass
        'SoftStab':    [1,0,0,0, 0,0,1,0, 0,1,0,0, 0,0,0,0],  // Gentle 3-hit pattern
        // --- DYADS & LIGHTER VOICINGS (less chord-heavy)
        'DyadPulse':   [2,0,2,0, 0,0,2,0, 2,0,0,0, 0,2,0,0],  // Two-note hits — lighter texture
        'DyadSparse':  [2,0,0,0, 0,0,0,0, 2,0,0,0, 0,0,0,0],  // Minimal dyads only
        'OctaveStab':  [4,0,0,0, 0,0,4,0, 0,0,0,0, 4,0,0,0],  // Root+octave — punchy, less dense
        'DyadArp':     [2,0,3,0, 0,3,0,2, 2,0,0,3, 0,0,3,0],  // Dyad + single notes blend
        // --- ARPEGGIOS (melodic motion)
        'Arpeggio':    [3,0,3,0, 3,0,3,0, 3,0,3,0, 3,0,3,0],  // 8th-note arpeggio
        'SlowArp':     [3,0,0,0, 3,0,0,0, 3,0,0,0, 3,0,0,0],  // Quarter-note arpeggio — gentle
        'SyncArp':     [3,0,0,3, 0,3,0,0, 3,0,0,3, 0,0,3,0],  // Syncopated
        'RollingArp':  [3,0,0,0, 0,3,0,0, 0,0,3,0, 0,0,0,3],  // Cascading down — dreamy
        // --- SPARSE / SINGLE-NOTE FOCUSED (less chord-heavy)
        'SingleLine':  [3,0,0,3, 0,0,3,0, 3,0,0,0, 0,3,0,0],  // Single notes only — no full chords
        'CallResponse':[1,0,0,0, 0,0,3,0, 0,0,0,0, 0,3,0,0],  // Chord on 1, melodic response on 3
        'PadTouch':    [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],  // Ultra minimal — one chord per bar
        'PassingFill': [3,0,5,0, 0,3,0,5, 3,0,0,0, 0,5,0,3],  // Arp + passing tones
        // --- BROKEN CHORD (mix chord + single notes)
        'Broken':      [1,0,0,3, 0,0,3,0, 1,0,0,0, 0,3,0,0],  // Chord, then melody notes respond
        'DreamBroken': [1,0,0,0, 0,0,0,3, 0,0,0,0, 0,3,0,0],  // Very sparse — chord and echoes
        'WaltzBroken': [1,0,0,0, 3,0,3,0, 0,0,0,0, 3,0,3,0],  // Waltz: chord then arp fill
        'Sparse':      [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,1,0],  // Ultra minimal — two hits, max space
    };
    // Mood weights: which patterns to favor per mood (hash-driven selection)
    const PIANO_MOOD_WEIGHTS = {
        Chill:      ['Block','BlockSlow','Sparse','DyadSparse','PadTouch','SlowArp','SoftStab'],
        Dreamy:     ['Arpeggio','SlowArp','RollingArp','SingleLine','DreamBroken','PadTouch','Sparse'],
        Groovy:     ['Comping','NeoSoulComp','Bounce','DyadPulse','DyadArp','RhodesHit','OffbeatChord'],
        Uplifting:  ['Bounce','Comping','Arpeggio','Broken','OctaveStab','RhodesHit'],
        Warm:       ['SoftStab','Broken','WaltzBroken','DyadArp','CallResponse','SlowArp']
    };
    const PIANO_INTRO_POOL = ['Sparse','SingleLine','SlowArp','PadTouch','DreamBroken','DyadSparse'];
    const PIANO_BREAKDOWN_POOL = ['Sparse','DyadSparse','PadTouch','DreamBroken'];  // Very sparse — hint of harmony in empty phase
    const PIANO_PATTERNS_34 = {
        'Waltz':       [1,0,0,0, 0,3,0,0, 0,3,0,0],
        'Block34':     [1,0,0,0, 0,0,0,0, 1,0,0,0],
        'Arp34':       [3,0,3,0, 3,0,3,0, 3,0,3,0],
        'Sparse34':    [1,0,0,0, 0,0,0,0, 0,0,1,0],
        'Dyad34':      [2,0,0,0, 0,0,2,0, 2,0,0,0],
        'Single34':    [3,0,3,0, 0,3,0,0, 3,0,0,0],
    };
    // --- LOFI ACCORDION PATTERNS. 0=rest, 1=full chord (sustained), 3=arpeggio note (16-step)
    // Accordion plays held chords and gentle melodic fills — breathing, warm, lo-fi texture
    const ACCORDION_PATTERNS = {
        'Sustain':  [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],  // One long held chord per bar
        'Gentle':   [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],  // Two gentle chords per bar
        'Breath':   [0,0,0,0, 1,0,0,0, 0,0,0,0, 0,0,1,0],  // Off-beat breathing feel
        'Waltz':    [1,0,0,0, 0,3,0,0, 0,3,0,0, 0,0,0,0],  // Chord then gentle arp fill
        'Arp':      [3,0,0,3, 0,0,3,0, 0,3,0,0, 3,0,0,0],  // Gentle rolling arpeggio
        'Dreamy':   [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,3,0],  // Sparse with single note tail
        'Float':    [0,0,1,0, 0,0,0,0, 0,0,0,0, 1,0,0,0],  // Floating off-beat pads
        'Sparse':   [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],  // Ultra minimal — once per bar
        'Swell':    [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,0,0],  // Late swell, atmospheric
        'Duet':     [1,0,0,0, 0,0,3,0, 0,0,0,0, 0,3,0,0],  // Chord with melodic response
        'Lullaby':  [1,0,0,0, 0,0,0,3, 0,0,1,0, 0,0,0,0],  // Soft rocking pattern
        'Mist':     [0,0,0,0, 1,0,0,0, 0,0,0,0, 0,0,0,0],  // Ghost-like single appearance
    };
    const ACCORDION_PATTERNS_34 = {
        'Waltz':    [1,0,0,0, 0,3,0,0, 0,0,0,0],
        'Sustain':  [1,0,0,0, 0,0,0,0, 0,0,0,0],
        'Gentle':   [1,0,0,0, 0,0,0,0, 1,0,0,0],
    };
    // --- HI-HAT PATTERNS. 0=rest, 1=closed, 2=ghost (soft), 3=open, 4=accent (loud closed) (16-step)
    // Colorful = mixing articulations, rolls, accents, and open/closed contrasts.
    const HIHAT_PATTERNS = {
        // --- STRAIGHT (foundation grooves)
        'Straight8':   [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],  // Classic 8ths
        'Straight16':  [1,2,1,2, 1,2,1,2, 1,2,1,2, 1,2,1,2],  // 16ths with ghost
        'Accent8':     [4,0,1,0, 4,0,1,0, 4,0,1,0, 4,0,1,0],  // Accented downbeats
        // --- SWING & GROOVE (hip-hop bounce)
        'Swing8':      [1,0,0,1, 1,0,0,1, 1,0,0,1, 1,0,0,1],  // Swung triplet feel
        'Groovy':      [4,0,2,0, 1,0,2,1, 4,0,2,0, 1,0,2,0],  // Accented groove with ghosts
        'Dilla':       [1,0,2,0, 4,0,0,2, 1,0,2,0, 0,2,0,1],  // Dilla pocket
        'BoomBap':     [4,0,1,0, 1,0,3,0, 4,0,1,0, 1,0,3,0],  // Boom-bap open hat on &
        'Shuffle':     [4,0,0,2, 1,0,0,2, 4,0,0,2, 1,0,0,1],  // Shuffle groove
        // --- OPEN/CLOSED CONTRAST (colorful dynamics)
        'OpenClose':   [1,0,1,0, 3,0,1,0, 1,0,1,0, 3,0,1,0],  // Alternating open/closed
        'OpenFill':    [1,0,1,0, 1,0,1,0, 1,0,1,0, 3,3,3,0],  // Fill with open hat run
        'WideOpen':    [3,0,0,0, 1,0,3,0, 0,0,1,0, 3,0,0,0],  // Sparse with lots of open
        'Sizzle':      [3,0,1,0, 3,0,1,0, 3,0,1,0, 3,0,1,0],  // Sizzle — open beats, closed offs
        // --- ROLLS & RUNS (energy and fills)
        'Roll':        [1,1,1,0, 1,0,1,0, 1,1,1,0, 1,0,1,0],  // 16th note rolls on 1
        'BuildRoll':   [1,0,1,0, 1,0,1,0, 1,2,1,2, 1,1,1,1],  // Builds to fill at end
        'TrapRoll':    [1,0,1,0, 1,0,1,1, 1,1,0,0, 1,1,1,0],  // Trap-influenced stutter
        'MachineGun':  [4,2,1,2, 4,2,1,2, 4,2,1,2, 1,1,1,1],  // Aggressive 16ths + fill
        // --- MINIMAL & GHOSTY (texture, breathing)
        'Minimal':     [1,0,0,0, 0,0,1,0, 1,0,0,0, 0,0,1,0],  // Sparse clicks
        'Lazy':        [0,0,1,0, 0,0,0,1, 0,0,1,0, 0,0,0,0],  // Behind the beat
        'GhostRide':   [2,0,2,0, 1,0,2,0, 2,0,2,0, 1,0,2,0],  // Ghost-heavy ride feel
        'Offbeat':     [0,0,4,0, 0,0,4,0, 0,0,4,0, 0,0,4,0],  // Accented offbeat only
    };
    const HIHAT_PATTERNS_34 = {
        'Waltz':    [1,0,1,0, 1,0,1,0, 1,0,1,0],
        'Sparse':   [1,0,0,0, 0,0,1,0, 1,0,0,0],
        'Triplet':  [1,0,2,0, 1,0,2,0, 1,0,2,0],
    };
    // --- LOFI HIT PROGRESSIONS ONLY (~80 major + ~80 minor). Soul, jazz, nostalgic.
    const FAMOUS_PROGRESSIONS = {
        major: [
            [1, 5, 6, 4], [1, 4, 5, 1], [1, 6, 4, 5], [4, 1, 5, 6], [1, 3, 4, 5], [2, 5, 1, 1], [1, 4, 1, 5], [6, 4, 1, 5],
            [1, 6, 2, 5], [2, 5, 1, 6], [4, 5, 1, 1], [1, 4, 6, 5], [6, 2, 5, 1], [3, 6, 4, 1], [1, 5, 1, 4], [4, 1, 1, 5],
            [1, 4, 2, 5], [5, 1, 4, 1], [1, 3, 6, 4], [6, 4, 2, 5], [2, 5, 6, 4], [1, 5, 4, 1], [4, 5, 6, 1], [1, 6, 4, 1],
            [3, 6, 2, 5], [1, 4, 3, 5], [6, 1, 4, 5], [2, 5, 4, 1], [5, 6, 4, 1], [1, 1, 4, 5], [4, 1, 6, 5], [1, 2, 5, 1],
            [6, 4, 5, 1], [1, 4, 5, 6], [5, 4, 1, 6], [3, 4, 5, 1], [1, 6, 5, 4], [4, 6, 1, 5], [2, 5, 1, 4], [1, 5, 6, 1],
            [6, 1, 5, 4], [5, 1, 6, 4], [1, 4, 6, 1], [4, 1, 4, 5], [1, 3, 4, 1], [6, 5, 4, 1], [1, 6, 3, 4], [2, 5, 6, 1],
            [4, 5, 1, 4], [1, 5, 4, 6], [3, 4, 1, 5], [6, 4, 1, 1], [1, 4, 5, 4], [5, 1, 4, 6], [1, 2, 5, 6], [4, 6, 5, 1],
            [1, 6, 4, 2], [2, 5, 4, 6], [1, 3, 5, 4], [6, 1, 4, 1], [5, 4, 6, 1], [1, 4, 1, 6], [4, 5, 6, 4], [1, 5, 1, 6],
            [3, 5, 1, 4], [6, 2, 5, 4], [1, 6, 1, 4], [4, 1, 5, 1], [1, 2, 4, 5], [5, 6, 1, 4], [2, 5, 1, 5], [1, 4, 2, 1],
            [6, 4, 4, 5], [4, 2, 5, 1], [1, 5, 6, 4], [3, 1, 4, 5], [1, 6, 5, 1], [5, 1, 1, 4], [4, 6, 1, 1], [1, 3, 2, 5],
            [6, 5, 1, 4], [2, 4, 5, 1], [1, 4, 4, 5], [4, 5, 2, 5], [1, 5, 2, 5], [5, 4, 1, 1], [6, 1, 2, 5], [1, 2, 6, 4],
            [4, 1, 2, 5], [3, 4, 6, 5], [1, 6, 2, 1], [6, 4, 5, 4], [1, 4, 5, 2], [2, 5, 4, 5], [4, 1, 6, 4], [1, 5, 3, 4],
            [5, 1, 2, 5], [6, 2, 4, 5], [1, 3, 6, 5], [4, 5, 4, 1], [1, 2, 1, 4], [6, 1, 4, 4], [1, 4, 3, 1], [2, 6, 5, 1],
            [5, 6, 1, 1], [1, 5, 4, 5], [4, 6, 4, 5], [3, 2, 5, 1], [1, 6, 6, 4], [6, 5, 2, 5], [4, 2, 1, 5], [1, 1, 6, 4]
        ],
        minor: [
            [1, 7, 6, 5], [6, 4, 1, 5], [1, 6, 2, 5], [1, 6, 4, 5], [4, 5, 1, 6], [2, 5, 1, 6], [1, 5, 6, 3], [4, 5, 3, 6],
            [1, 4, 1, 5], [1, 7, 4, 5], [6, 1, 4, 5], [1, 6, 5, 4], [4, 1, 5, 6], [2, 5, 6, 1], [1, 5, 4, 6], [3, 6, 4, 1],
            [1, 4, 6, 5], [7, 6, 5, 1], [1, 6, 4, 1], [6, 4, 5, 1], [4, 5, 6, 3], [1, 5, 1, 4], [4, 1, 6, 5], [2, 5, 4, 1],
            [1, 7, 5, 6], [6, 1, 5, 4], [1, 3, 4, 5], [4, 6, 1, 5], [1, 6, 3, 4], [5, 1, 6, 4], [6, 5, 4, 1], [1, 4, 5, 1],
            [4, 1, 1, 5], [1, 5, 6, 1], [7, 4, 1, 5], [6, 4, 1, 1], [1, 2, 5, 6], [4, 5, 1, 4], [1, 6, 2, 1], [2, 5, 1, 4],
            [1, 4, 2, 5], [6, 2, 5, 1], [1, 7, 6, 1], [4, 1, 4, 5], [1, 5, 4, 1], [6, 4, 2, 5], [4, 5, 4, 1], [1, 3, 6, 4],
            [1, 6, 5, 1], [5, 6, 1, 4], [1, 4, 6, 1], [7, 1, 6, 5], [6, 1, 4, 1], [1, 5, 2, 5], [4, 6, 5, 1], [2, 5, 6, 4],
            [1, 2, 5, 1], [6, 5, 1, 5], [1, 7, 4, 1], [4, 1, 5, 1], [1, 6, 4, 2], [5, 4, 1, 6], [6, 4, 5, 4], [1, 4, 1, 6],
            [4, 5, 6, 1], [1, 5, 1, 6], [7, 6, 1, 5], [6, 1, 2, 5], [1, 3, 5, 6], [4, 2, 5, 1], [1, 6, 1, 4], [2, 5, 4, 6],
            [1, 4, 5, 6], [6, 4, 1, 4], [1, 5, 6, 5], [4, 1, 2, 5], [1, 7, 1, 6], [5, 1, 4, 5], [6, 5, 4, 6], [1, 2, 6, 5],
            [4, 5, 2, 5], [1, 6, 6, 4], [7, 4, 5, 1], [6, 2, 5, 4], [1, 4, 4, 5], [4, 6, 1, 1], [1, 5, 4, 5], [3, 6, 1, 5],
            [1, 3, 6, 5], [6, 4, 6, 5], [1, 4, 2, 1], [5, 6, 4, 1], [1, 7, 5, 1], [4, 5, 1, 2], [6, 1, 5, 1], [1, 2, 4, 5],
            [4, 1, 6, 1], [1, 5, 3, 6], [7, 1, 4, 5], [6, 5, 1, 4], [1, 6, 4, 5], [4, 2, 1, 6], [1, 4, 6, 4], [2, 5, 1, 1],
            [1, 5, 1, 5], [6, 1, 6, 4], [4, 5, 4, 6], [1, 3, 4, 6], [1, 7, 6, 4], [5, 1, 6, 1], [6, 4, 1, 2], [1, 2, 5, 4],
            [4, 6, 5, 4], [1, 6, 2, 4], [7, 5, 6, 1], [6, 1, 4, 5], [1, 4, 5, 4], [4, 1, 4, 1], [1, 5, 6, 2], [3, 4, 5, 6],
            [1, 2, 1, 5], [6, 5, 2, 5], [4, 5, 6, 5], [1, 7, 4, 6], [1, 6, 5, 6], [5, 4, 6, 1], [6, 2, 1, 5], [1, 4, 2, 6],
            [4, 1, 5, 4], [1, 5, 4, 1], [7, 6, 4, 5], [6, 4, 6, 1], [1, 3, 2, 5], [4, 2, 5, 6], [1, 6, 1, 5], [2, 6, 1, 5],
            [1, 4, 1, 4], [6, 1, 1, 4], [4, 6, 4, 1], [1, 5, 2, 1], [1, 7, 1, 4], [5, 6, 1, 5], [6, 5, 1, 1], [1, 2, 4, 1],
            [4, 5, 1, 5], [1, 6, 4, 6], [7, 4, 1, 6], [6, 2, 4, 1], [1, 4, 5, 2], [4, 1, 2, 1], [1, 5, 1, 1], [3, 1, 6, 5],
            [1, 3, 5, 4], [6, 4, 5, 6], [4, 5, 2, 1], [1, 7, 2, 5], [1, 6, 6, 5], [5, 1, 5, 6], [6, 1, 2, 1], [1, 2, 6, 1],
            [4, 1, 2, 6], [1, 5, 4, 4], [7, 1, 6, 4], [6, 5, 4, 5], [1, 4, 6, 2], [4, 6, 2, 5], [1, 6, 2, 6], [2, 5, 2, 5],
            [1, 4, 4, 1], [6, 1, 5, 6], [4, 5, 4, 5], [1, 7, 6, 6], [1, 5, 3, 1], [5, 4, 1, 4], [6, 4, 2, 1], [1, 2, 1, 6],
            [4, 2, 1, 5], [1, 6, 3, 5], [7, 5, 1, 6], [6, 2, 1, 4], [1, 4, 2, 4], [4, 1, 6, 2], [1, 5, 6, 6], [3, 6, 2, 5],
            [1, 3, 6, 1], [6, 5, 6, 1], [4, 1, 5, 2], [1, 7, 5, 4], [1, 6, 1, 6], [5, 6, 4, 5], [6, 1, 4, 6], [1, 2, 5, 1],
            [4, 5, 6, 2], [1, 5, 2, 1], [7, 4, 6, 5], [6, 4, 1, 3], [1, 4, 3, 5], [4, 6, 5, 6], [1, 6, 5, 2], [2, 5, 4, 1]
        ]
    };
    // --- LOFI HOOK CONTOURS. Scale degrees 0..7 (7 = root up octave). Mature contours: leaps, 7th tension, less nursery-rhyme stepwise.
    const MOTIF_CONTOURS = [
        // --- Mature / sophisticated (leaps, tension, unexpected motion) — weighted first so they're picked more
        [0, 3, 5, 2, 0], [2, 5, 0, 3, 6], [4, 1, 6, 3, 0], [0, 4, 2, 6, 3, 1], [3, 6, 2, 5, 0],
        [1, 4, 2, 0, 3, 5], [5, 2, 0, 4, 1], [0, 2, 5, 3, 1, 4], [6, 3, 0, 4, 2], [2, 0, 4, 1, 6, 3],
        [4, 6, 2, 0, 3], [0, 5, 2, 6, 4, 1], [3, 0, 5, 2, 6, 1], [1, 6, 4, 2, 0, 3], [5, 3, 6, 2, 0],
        [0, 4, 1, 5, 2, 6], [6, 2, 5, 0, 3, 1], [2, 6, 3, 0, 4], [3, 5, 0, 2, 6, 1], [0, 3, 6, 2, 4, 0],
        [4, 0, 2, 5, 3, 1], [1, 3, 6, 4, 0, 2], [5, 0, 3, 6, 2], [0, 6, 3, 1, 4, 2], [2, 4, 0, 6, 3, 5],
        [6, 4, 1, 3, 0, 2], [3, 1, 4, 6, 2, 0], [0, 2, 4, 6, 3, 1], [1, 5, 2, 0, 4, 3], [5, 1, 4, 0, 6, 2],
        [2, 5, 1, 4, 0], [0, 4, 6, 2, 5, 0], [4, 2, 6, 0, 3, 5], [3, 0, 4, 2, 6, 1], [6, 0, 3, 5, 1, 2],
        [0, 5, 3, 1, 6, 4], [1, 4, 6, 3, 0, 5], [5, 2, 6, 0, 4], [2, 6, 1, 4, 0, 3], [0, 3, 5, 1, 4, 2],
        [4, 1, 3, 6, 2, 0], [3, 6, 0, 2, 5, 1], [6, 1, 0, 4, 2, 5], [0, 2, 6, 4, 1, 3], [1, 6, 2, 0, 5, 3],
        [5, 0, 2, 4, 6, 1], [2, 4, 3, 0, 6, 1], [0, 6, 4, 3, 1, 2], [4, 3, 0, 5, 2, 6], [3, 2, 6, 1, 4, 0],
        // --- With octave (7 = root up): more dramatic, less predictable
        [0, 7, 3, 5, 2], [2, 5, 7, 0, 3], [4, 0, 7, 2, 5], [0, 4, 7, 2, 6, 3], [6, 3, 0, 7, 2],
        [1, 4, 7, 0, 3], [5, 2, 0, 7, 4], [0, 2, 5, 7, 3, 1], [3, 7, 0, 4, 2], [2, 0, 7, 4, 1],
        [4, 6, 2, 7, 0], [0, 5, 7, 2, 6], [3, 0, 5, 7, 2], [1, 6, 4, 7, 0, 3], [5, 3, 6, 7, 0],
        // --- Emotional / lo-fi (longing, melancholic) — wider range, 7th tension
        [5, 4, 3, 2, 1, 0], [5, 5, 4, 3, 2, 1], [4, 3, 2, 1, 0, 1], [0, 1, 2, 3, 4, 3], [6, 5, 4, 3, 2, 1],
        [3, 2, 1, 0, 1, 2], [4, 4, 3, 2, 1, 0], [6, 5, 4, 3, 2, 0], [1, 2, 3, 2, 1, 0, 1], [0, 2, 1, 0, 2, 1],
        [3, 3, 2, 1, 0], [2, 1, 2, 1, 0, 1], [0, 1, 2, 3, 1, 0], [2, 5, 3, 0, 4, 1], [0, 3, 2, 1, 0, 1, 2],
        [1, 2, 3, 1, 2, 0], [0, 2, 3, 2, 1, 0, 1], [1, 1, 2, 0, 2, 1], [4, 2, 0, 3, 1], [2, 1, 0, 1, 2, 0],
        // --- Fewer stepwise-only (kept for variety but outnumbered by mature contours)
        [0, 2, 4, 2, 0], [0, 2, 3, 2, 0], [1, 2, 3, 4, 3, 2, 1], [0, 1, 2, 1, 0], [3, 2, 3, 2, 1, 0],
        [0, 1, 2, 2, 1, 0], [0, 3, 2, 1, 0], [2, 0, 2, 3, 2, 0], [0, 1, 2, 3, 2, 1], [0, 2, 1, 0, 2, 0],
        [2, 3, 4, 3, 2, 1], [0, 2, 1, 2, 0], [1, 2, 1, 0, 1, 2], [3, 2, 1, 0, 0, 1], [2, 1, 0, 2, 0, 1]
    ];

    // --- MELODY RHYTHM PROFILES: per-track variety so not every song uses same note lengths (lo-fi knowledge).
    // Each profile = { lead: duration pool, bell: duration pool, leadStepMod: step filter for when lead can play, bellStepMod: for bells }
    // leadStepMod/bellStepMod: 0 = every eligible step, 1 = half the steps (sparser), 2 = only on specific beats (e.g. 4 or 8)
    const MELODY_RHYTHM_PROFILES = [
        { name: 'Sustained', lead: ['2n','2n','1n','4n','2n','4n'], bell: ['2n','4n','4n','2n'], leadStepMod: 1, bellStepMod: 1 },
        { name: 'Syncopated', lead: ['4n','8n','8n.','16n','8n','4n'], bell: ['8n','8n.','16n','4n'], leadStepMod: 0, bellStepMod: 0 },
        { name: 'Grounded', lead: ['4n','4n','4n','8n','2n','4n'], bell: ['4n','8n','4n','8n'], leadStepMod: 0, bellStepMod: 1 },
        { name: 'Breathy', lead: ['16n','8n','8n','16n','8n'], bell: ['8n','16n','8n','16n'], leadStepMod: 1, bellStepMod: 1 },
        { name: 'Lyrical', lead: ['8n','4n','8n','8n','4n','2n','8n'], bell: ['4n','8n','4n','8n','2n'], leadStepMod: 0, bellStepMod: 0 },
        { name: 'Longing', lead: ['2n','1n','2n','4n','2n'], bell: ['2n','4n','2n','4n'], leadStepMod: 1, bellStepMod: 1 },
        { name: 'Sparkle', lead: ['8n','16n','8n','4n','16n'], bell: ['16n','8n','16n','8n','8n'], leadStepMod: 0, bellStepMod: 0 },
        { name: 'Nostalgic', lead: ['4n','4n.','8n','4n','2n'], bell: ['4n','8n','4n','2n'], leadStepMod: 0, bellStepMod: 1 },
        { name: 'Dreamy', lead: ['2n','4n','2n','4n','1n'], bell: ['2n','2n','4n','4n'], leadStepMod: 1, bellStepMod: 1 },
        { name: 'Hopeful', lead: ['8n','8n','4n','4n','8n','2n'], bell: ['8n','4n','8n','4n'], leadStepMod: 0, bellStepMod: 0 },
        { name: 'Melancholic', lead: ['4n','2n','4n','8n','2n','4n'], bell: ['2n','4n','4n','8n'], leadStepMod: 1, bellStepMod: 0 },
        { name: 'Minimal', lead: ['4n','2n','4n','2n'], bell: ['4n','2n','4n'], leadStepMod: 1, bellStepMod: 1 }
    ];

    // --- HIP-HOP / CHILL HOP / TRIP HOP STYLES. BPM 62–90, swing for head-nod groove, bit-crush for lo-fi color.
    const STYLES = {
        'Chill Hop': { bpmRange: [76, 88], swing: 0.058, drumDensity: 0.62, bitCrush: 0, hasLead: true, isGuitar: false, color: '#e07c54' },
        'Classic': { bpmRange: [72, 84], swing: 0.052, drumDensity: 0.52, bitCrush: 4, hasLead: true, isGuitar: false, color: '#d4a055' },
        'Trip Hop': { bpmRange: [62, 76], swing: 0.056, drumDensity: 0.45, bitCrush: 4, hasLead: true, isGuitar: false, color: '#4a5568' },
        'Jazzy': { bpmRange: [74, 88], swing: 0.068, drumDensity: 0.58, bitCrush: 2, hasLead: true, isGuitar: false, color: '#7c5cbf' },
        'Neo-Soul': { bpmRange: [76, 90], swing: 0.07, drumDensity: 0.62, bitCrush: 2, hasLead: true, isGuitar: false, color: '#b56576' },
        'Vintage': { bpmRange: [72, 84], swing: 0.056, drumDensity: 0.52, bitCrush: 3, hasLead: true, isGuitar: false, color: '#c9a959' },
        'Sleepy': { bpmRange: [64, 74], swing: 0.042, drumDensity: 0.32, bitCrush: 6, hasLead: false, isGuitar: false, color: '#5b7c99' },
        'Minimal': { bpmRange: [68, 80], swing: 0.045, drumDensity: 0.38, bitCrush: 5, hasLead: false, isGuitar: false, color: '#6b7280' },
        'Study': { bpmRange: [74, 86], swing: 0.05, drumDensity: 0.48, bitCrush: 4, hasLead: true, isGuitar: false, color: '#84a98c' },
        'Twilight': { bpmRange: [70, 82], swing: 0.05, drumDensity: 0.42, bitCrush: 4, hasLead: true, isGuitar: false, color: '#7c8ba3' },
        'Rainy': { bpmRange: [68, 80], swing: 0.048, drumDensity: 0.42, bitCrush: 4, hasLead: true, isGuitar: false, color: '#6b8cae' },
        'Soft': { bpmRange: [68, 78], swing: 0.046, drumDensity: 0.38, bitCrush: 5, hasLead: true, isGuitar: false, color: '#a8b5a0' },
        'Warm': { bpmRange: [74, 86], swing: 0.054, drumDensity: 0.55, bitCrush: 3, hasLead: true, isGuitar: false, color: '#c4785a' },
        'Mellow': { bpmRange: [70, 82], swing: 0.052, drumDensity: 0.48, bitCrush: 4, hasLead: true, isGuitar: false, color: '#9ca777' },
        'Cozy': { bpmRange: [66, 78], swing: 0.05, drumDensity: 0.42, bitCrush: 4, hasLead: true, isGuitar: false, color: '#8b7355' },
        'Sunrise': { bpmRange: [74, 86], swing: 0.05, drumDensity: 0.46, bitCrush: 3, hasLead: true, isGuitar: false, color: '#f4a261' }
    };
    // Style weights: hip-hop / chill hop / trip hop styles favored
    const STYLE_WEIGHTS = {
        'Chill Hop': 4, 'Classic': 4, 'Trip Hop': 3, 'Jazzy': 4, 'Neo-Soul': 4, 'Vintage': 4,
        'Mellow': 2, 'Warm': 2, 'Cozy': 2, 'Twilight': 2, 'Rainy': 2,
        'Study': 1, 'Soft': 1, 'Minimal': 1, 'Sleepy': 1, 'Sunrise': 1
    };
    // Drum pattern weights: boom-bap, Dilla, chill hop, jazz hop, neo-soul, half-time (trip hop) favored
    const DRUM_WEIGHTS = {
        'BoomBap': 3, 'BoomBap2': 2, 'Dilla': 3, 'DillaSwing': 3, 'ChillHop': 3, 'JazzHop': 3,
        'Lofi': 3, 'LofiHeavy': 2, 'NeoSoul': 3, 'Pocket': 3, 'Swing': 2, 'Shuffle': 2,
        'HalfTime': 2, 'Backbeat': 1, 'Trap': 0.5, 'Broken': 0.5
    };

    // --- LOFI SOUND BANKS (10x variation). Keys, pad, bass, lead, effects, drums — hit tones only.
    // Keys: FM synthesis for piano-like tones — the LEAD instrument, must be clearly audible.
    // Piano has its own reverb→compressor path (bypasses masterFilter lowpass that was killing it).
    // Sustain 0.2-0.4 so notes ring clearly. Volume -6 to -9: piano sits ON TOP of the mix.
    const KEY_PATCHES = [
        // Bright upright piano — punchy attack, rich harmonics, ringing sustain
        { harmonicity: 3.5, modulationIndex: 5, envelope: { attack: 0.005, decay: 0.6, sustain: 0.25, release: 1.2 }, modulationEnvelope: { attack: 0.002, decay: 0.3, sustain: 0, release: 0.4 }, volume: -7 },
        // Warm felt piano — softer attack, mellow body, long ring
        { harmonicity: 2, modulationIndex: 3, envelope: { attack: 0.01, decay: 0.8, sustain: 0.3, release: 1.6 }, modulationEnvelope: { attack: 0.003, decay: 0.4, sustain: 0, release: 0.6 }, volume: -6 },
        // Dusty Rhodes — bell-like FM tone, singing sustain
        { harmonicity: 4, modulationIndex: 6, envelope: { attack: 0.003, decay: 0.5, sustain: 0.22, release: 1.0 }, modulationEnvelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.3 }, volume: -7 },
        // Tape-saturated piano — slightly crunchy, moderate sustain
        { harmonicity: 3, modulationIndex: 4.5, envelope: { attack: 0.005, decay: 0.5, sustain: 0.2, release: 0.9 }, modulationEnvelope: { attack: 0.002, decay: 0.2, sustain: 0, release: 0.35 }, volume: -6 },
        // Dreamy keys — softer modulation, longest sustain for reverb tails
        { harmonicity: 2.5, modulationIndex: 2.5, envelope: { attack: 0.012, decay: 0.9, sustain: 0.4, release: 1.8 }, modulationEnvelope: { attack: 0.005, decay: 0.5, sustain: 0.02, release: 0.7 }, volume: -8 },
        // Punchy lo-fi — very fast attack, bright, snappy
        { harmonicity: 3.5, modulationIndex: 5.5, envelope: { attack: 0.002, decay: 0.4, sustain: 0.2, release: 0.8 }, modulationEnvelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.25 }, volume: -6 },
        // Vintage Wurlitzer — medium harmonicity, warm body, singing
        { harmonicity: 2, modulationIndex: 3.5, envelope: { attack: 0.008, decay: 0.6, sustain: 0.28, release: 1.2 }, modulationEnvelope: { attack: 0.003, decay: 0.35, sustain: 0, release: 0.5 }, volume: -7 },
        // Glass piano — high harmonicity for shimmer, clear
        { harmonicity: 5, modulationIndex: 4, envelope: { attack: 0.003, decay: 0.5, sustain: 0.22, release: 1.0 }, modulationEnvelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.2 }, volume: -8 },
        // Mellow upright — round tone, gentle attack, warm sustain
        { harmonicity: 2.5, modulationIndex: 3, envelope: { attack: 0.01, decay: 0.7, sustain: 0.3, release: 1.4 }, modulationEnvelope: { attack: 0.004, decay: 0.4, sustain: 0, release: 0.55 }, volume: -7 },
        // Bright studio piano — clear articulation, present
        { harmonicity: 3, modulationIndex: 5, envelope: { attack: 0.004, decay: 0.6, sustain: 0.25, release: 1.1 }, modulationEnvelope: { attack: 0.002, decay: 0.22, sustain: 0, release: 0.35 }, volume: -6 },
        // Lo-fi toy piano — quirky character, moderate ring
        { harmonicity: 6, modulationIndex: 3, envelope: { attack: 0.002, decay: 0.4, sustain: 0.18, release: 0.7 }, modulationEnvelope: { attack: 0.001, decay: 0.12, sustain: 0, release: 0.15 }, volume: -9 },
        // Smooth jazz keys — warm, long sustain, singing
        { harmonicity: 2, modulationIndex: 2, envelope: { attack: 0.015, decay: 0.9, sustain: 0.35, release: 1.6 }, modulationEnvelope: { attack: 0.005, decay: 0.5, sustain: 0.03, release: 0.7 }, volume: -7 }
    ];
    // Pads: very subtle background warmth (breakdown only). Low volume, short sustain — NOT a drone.
    const PAD_PATCHES = [
        { oscillator: { type: 'sine' }, envelope: { attack: 1.2, decay: 0.6, sustain: 0.12, release: 1.0 }, volume: -36 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.9, decay: 0.5, sustain: 0.1, release: 0.9 }, volume: -35 },
        { oscillator: { type: 'sine' }, envelope: { attack: 1.5, decay: 0.7, sustain: 0.14, release: 1.1 }, volume: -37 },
        { oscillator: { type: 'fatsine' }, envelope: { attack: 1.1, decay: 0.6, sustain: 0.1, release: 1.0 }, volume: -36 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.6, decay: 0.4, sustain: 0.08, release: 0.8 }, volume: -35 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 1.4, decay: 0.7, sustain: 0.12, release: 1.1 }, volume: -37 },
        { oscillator: { type: 'sine' }, envelope: { attack: 1.2, decay: 0.6, sustain: 0.1, release: 0.9 }, volume: -38 },
        { oscillator: { type: 'sine' }, envelope: { attack: 1.0, decay: 0.5, sustain: 0.08, release: 0.8 }, volume: -35 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 1.6, decay: 0.7, sustain: 0.14, release: 1.2 }, volume: -36 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.7, decay: 0.4, sustain: 0.06, release: 0.7 }, volume: -34 },
        { oscillator: { type: 'fatsine' }, envelope: { attack: 1.3, decay: 0.6, sustain: 0.1, release: 1.0 }, volume: -36 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.9, decay: 0.5, sustain: 0.08, release: 0.9 }, volume: -35 }
    ];
    // Bass: Hip-hop sub — punchy attack with deep sustain. Sine FM through 500Hz lowpass.
    // Faster attacks + higher modulationIndex = more presence and punch for hip-hop groove.
    const BASS_PATCHES = [
        // 808 punch — fast attack, long sustain, classic hip-hop
        { harmonicity: 1, modulationIndex: 1.2, envelope: { attack: 0.005, decay: 0.35, sustain: 0.75, release: 0.8 }, modulationEnvelope: { attack: 0.003, decay: 0.2, sustain: 0.08, release: 0.3 }, volume: -4 },
        // Boom-bap sub — round but punchy
        { harmonicity: 1, modulationIndex: 1.5, envelope: { attack: 0.003, decay: 0.3, sustain: 0.7, release: 0.7 }, modulationEnvelope: { attack: 0.002, decay: 0.15, sustain: 0.05, release: 0.25 }, volume: -3 },
        // Deep 808 tail — long decay for sustained pressure
        { harmonicity: 0.5, modulationIndex: 0.8, envelope: { attack: 0.005, decay: 0.6, sustain: 0.8, release: 1.2 }, modulationEnvelope: { attack: 0.003, decay: 0.25, sustain: 0.06, release: 0.35 }, volume: -4 },
        // Tight punch — shortest decay, locks with kick
        { harmonicity: 1, modulationIndex: 1.8, envelope: { attack: 0.002, decay: 0.25, sustain: 0.5, release: 0.5 }, modulationEnvelope: { attack: 0.001, decay: 0.12, sustain: 0, release: 0.2 }, volume: -3 },
        // Moog groove — warm with modulation presence
        { harmonicity: 1, modulationIndex: 2, envelope: { attack: 0.008, decay: 0.35, sustain: 0.7, release: 0.9 }, modulationEnvelope: { attack: 0.005, decay: 0.2, sustain: 0.1, release: 0.3 }, volume: -4 },
        // Rubber bounce — funky, bouncy hip-hop feel
        { harmonicity: 1, modulationIndex: 1, envelope: { attack: 0.005, decay: 0.3, sustain: 0.65, release: 0.6 }, modulationEnvelope: { attack: 0.003, decay: 0.2, sustain: 0.05, release: 0.25 }, volume: -4 },
        // Lo-fi tape bass — saturated warmth with attack
        { harmonicity: 1, modulationIndex: 2.2, envelope: { attack: 0.004, decay: 0.35, sustain: 0.7, release: 0.8 }, modulationEnvelope: { attack: 0.003, decay: 0.18, sustain: 0.1, release: 0.3 }, volume: -4 },
        // Dilla pocket — medium everything, groovy
        { harmonicity: 0.5, modulationIndex: 1.2, envelope: { attack: 0.008, decay: 0.4, sustain: 0.75, release: 0.9 }, modulationEnvelope: { attack: 0.005, decay: 0.22, sustain: 0.08, release: 0.35 }, volume: -4 },
        // Hard knock — tight, aggressive attack
        { harmonicity: 1.5, modulationIndex: 2.5, envelope: { attack: 0.002, decay: 0.2, sustain: 0.45, release: 0.4 }, modulationEnvelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.15 }, volume: -3 },
        // Round hip-hop — clean, present
        { harmonicity: 1, modulationIndex: 1, envelope: { attack: 0.006, decay: 0.35, sustain: 0.7, release: 0.8 }, modulationEnvelope: { attack: 0.004, decay: 0.2, sustain: 0.06, release: 0.3 }, volume: -4 },
        // Fat sub — wide, sustained, fills the low end
        { harmonicity: 0.5, modulationIndex: 0.8, envelope: { attack: 0.005, decay: 0.5, sustain: 0.8, release: 1.0 }, modulationEnvelope: { attack: 0.003, decay: 0.25, sustain: 0.08, release: 0.35 }, volume: -4 },
        // Punchy synth bass — snappy, defined
        { harmonicity: 1, modulationIndex: 1.5, envelope: { attack: 0.003, decay: 0.28, sustain: 0.6, release: 0.6 }, modulationEnvelope: { attack: 0.002, decay: 0.15, sustain: 0.04, release: 0.25 }, volume: -3 }
    ];
    // Lead: very quiet background accent (no square — sine/triangle only, well behind the beat)
    const LEAD_PATCHES = [
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.04, decay: 0.18, sustain: 0.12, release: 0.7 }, volume: -32 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.06, decay: 0.22, sustain: 0.15, release: 0.8 }, volume: -31 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.15, sustain: 0.1, release: 0.6 }, volume: -33 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.12, release: 0.75 }, volume: -32 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.08, decay: 0.25, sustain: 0.18, release: 0.9 }, volume: -31 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.03, decay: 0.2, sustain: 0.11, release: 0.65 }, volume: -32 },
        { oscillator: { type: 'fatsine' }, envelope: { attack: 0.05, decay: 0.19, sustain: 0.14, release: 0.75 }, volume: -31 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.04, decay: 0.16, sustain: 0.1, release: 0.6 }, volume: -33 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.07, decay: 0.24, sustain: 0.16, release: 0.85 }, volume: -31 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.03, decay: 0.18, sustain: 0.1, release: 0.6 }, volume: -34 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.06, decay: 0.21, sustain: 0.14, release: 0.75 }, volume: -32 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.12, release: 0.7 }, volume: -32 }
    ];
    // Accordion: AM synthesis for reed-like warmth. Square partials = reed buzzing.
    // Slow attack mimics bellows opening. Routed through tremolo for characteristic wavering.
    const ACCORDION_PATCHES = [
        // Warm musette — gentle reed character, slow breathe
        { harmonicity: 2, oscillator: { type: 'square8' }, envelope: { attack: 0.15, decay: 0.5, sustain: 0.55, release: 1.4 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.1, decay: 0.3, sustain: 0.25, release: 0.6 }, volume: -24 },
        // Soft bandoneon — darker, more mellow
        { harmonicity: 1.5, oscillator: { type: 'square8' }, envelope: { attack: 0.2, decay: 0.6, sustain: 0.5, release: 1.6 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.12, decay: 0.35, sustain: 0.2, release: 0.7 }, volume: -25 },
        // Bright concertina — slightly more presence
        { harmonicity: 2.5, oscillator: { type: 'square16' }, envelope: { attack: 0.1, decay: 0.45, sustain: 0.6, release: 1.2 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.08, decay: 0.25, sustain: 0.3, release: 0.5 }, volume: -23 },
        // Dreamy melodica — airy, breathy
        { harmonicity: 1, oscillator: { type: 'square8' }, envelope: { attack: 0.25, decay: 0.7, sustain: 0.45, release: 1.8 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.15, decay: 0.4, sustain: 0.15, release: 0.8 }, volume: -26 },
        // Lo-fi accordion — with subtle grit
        { harmonicity: 2, oscillator: { type: 'square4' }, envelope: { attack: 0.12, decay: 0.5, sustain: 0.5, release: 1.3 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.08, decay: 0.3, sustain: 0.2, release: 0.55 }, volume: -24 },
        // Ethereal harmonium — long sustain, very gentle
        { harmonicity: 1.5, oscillator: { type: 'square16' }, envelope: { attack: 0.3, decay: 0.8, sustain: 0.6, release: 2.0 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.2, decay: 0.5, sustain: 0.2, release: 0.9 }, volume: -27 },
        // Café accordion — warm, nostalgic
        { harmonicity: 2, oscillator: { type: 'square8' }, envelope: { attack: 0.14, decay: 0.55, sustain: 0.52, release: 1.5 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.1, decay: 0.32, sustain: 0.22, release: 0.6 }, volume: -25 },
        // Tango reed — expressive, slightly brighter
        { harmonicity: 2.5, oscillator: { type: 'square8' }, envelope: { attack: 0.1, decay: 0.45, sustain: 0.58, release: 1.2 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.06, decay: 0.28, sustain: 0.25, release: 0.5 }, volume: -24 },
        // Whisper accordion — very soft, background texture
        { harmonicity: 1, oscillator: { type: 'square16' }, envelope: { attack: 0.35, decay: 0.8, sustain: 0.4, release: 2.2 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.2, decay: 0.5, sustain: 0.12, release: 1.0 }, volume: -28 },
        // Vintage pump organ — church-like warmth
        { harmonicity: 1.5, oscillator: { type: 'square4' }, envelope: { attack: 0.2, decay: 0.6, sustain: 0.55, release: 1.7 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.12, decay: 0.4, sustain: 0.18, release: 0.7 }, volume: -25 },
        // Gentle reed organ — mellow, sustained
        { harmonicity: 2, oscillator: { type: 'square8' }, envelope: { attack: 0.18, decay: 0.55, sustain: 0.5, release: 1.5 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.1, decay: 0.35, sustain: 0.2, release: 0.65 }, volume: -25 },
        // Soft celeste accordion — shimmering, light
        { harmonicity: 3, oscillator: { type: 'square16' }, envelope: { attack: 0.2, decay: 0.6, sustain: 0.48, release: 1.6 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.12, decay: 0.35, sustain: 0.25, release: 0.7 }, volume: -26 }
    ];
    // Bells / glockenspiel — very subtle high accent, short decay, soft.
    const BELL_PATCHES = [
        { oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.35 }, volume: -36 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.008, decay: 0.5, sustain: 0, release: 0.4 }, volume: -37 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.015, decay: 0.35, sustain: 0, release: 0.3 }, volume: -35 },
        { oscillator: { type: 'triangle' }, envelope: { attack: 0.012, decay: 0.55, sustain: 0.02, release: 0.45 }, volume: -38 },
        { oscillator: { type: 'sine' }, envelope: { attack: 0.02, decay: 0.45, sustain: 0, release: 0.38 }, volume: -37 }
    ];

    // Effects: gentle and warm. Filter ranges raised for piano clarity. Tremolo/vibrato kept subtle.
    const EFFECT_PRESETS = [
        { reverbDecay: 0.28, delayWet: 0.10, chorusWet: 0.18, filterMin: 1800, filterMax: 5500, tremoloWet: 0.04, vibratoWet: 0.02 },
        { reverbDecay: 0.32, delayWet: 0.14, chorusWet: 0.22, filterMin: 2000, filterMax: 6000, tremoloWet: 0.06, vibratoWet: 0.025 },
        { reverbDecay: 0.22, delayWet: 0.06, chorusWet: 0.14, filterMin: 1500, filterMax: 4500, tremoloWet: 0.02, vibratoWet: 0.015 },
        { reverbDecay: 0.36, delayWet: 0.16, chorusWet: 0.24, filterMin: 2200, filterMax: 6500, tremoloWet: 0.08, vibratoWet: 0.03 },
        { reverbDecay: 0.25, delayWet: 0.08, chorusWet: 0.16, filterMin: 1600, filterMax: 5000, tremoloWet: 0.03, vibratoWet: 0.02 },
        { reverbDecay: 0.34, delayWet: 0.12, chorusWet: 0.20, filterMin: 2100, filterMax: 6200, tremoloWet: 0.06, vibratoWet: 0.025 },
        { reverbDecay: 0.28, delayWet: 0.10, chorusWet: 0.18, filterMin: 1700, filterMax: 5500, tremoloWet: 0.04, vibratoWet: 0.02 },
        { reverbDecay: 0.20, delayWet: 0.05, chorusWet: 0.12, filterMin: 1400, filterMax: 4000, tremoloWet: 0.02, vibratoWet: 0.01 },
        { reverbDecay: 0.38, delayWet: 0.18, chorusWet: 0.26, filterMin: 2400, filterMax: 7000, tremoloWet: 0.08, vibratoWet: 0.03 },
        { reverbDecay: 0.24, delayWet: 0.08, chorusWet: 0.16, filterMin: 1600, filterMax: 4800, tremoloWet: 0.03, vibratoWet: 0.02 },
        { reverbDecay: 0.30, delayWet: 0.10, chorusWet: 0.18, filterMin: 1900, filterMax: 5800, tremoloWet: 0.05, vibratoWet: 0.02 },
        { reverbDecay: 0.22, delayWet: 0.06, chorusWet: 0.14, filterMin: 1500, filterMax: 4500, tremoloWet: 0.02, vibratoWet: 0.015 }
    ];
    const DRUM_TONES = [
        // Boom-bap punchy — tight kick, snappy snare, bright hat
        { kickDecay: 0.25, snareDecay: 0.12, hihatFreq: 160, hihatDecay: 0.03 },
        // Dilla pocket — rounder kick, slightly longer snare
        { kickDecay: 0.3, snareDecay: 0.14, hihatFreq: 150, hihatDecay: 0.035 },
        // Classic lo-fi — medium punch, warm hat
        { kickDecay: 0.28, snareDecay: 0.13, hihatFreq: 140, hihatDecay: 0.032 },
        // Hard knock — short kick, tight snare, crisp hat
        { kickDecay: 0.2, snareDecay: 0.1, hihatFreq: 170, hihatDecay: 0.028 },
        // Dusty groove — looser feel, medium everything
        { kickDecay: 0.32, snareDecay: 0.15, hihatFreq: 145, hihatDecay: 0.036 }
    ];

    const state = {
        isPlaying: false,
        timeOffset: 0, 
        currentSeed: 0,
        trackStartTime: 0,
        trackDuration: 0,
        
        style: 'Classic',
        mood: 'Chill',
        key: 'C',
        mode: 'Minor',
        scale: [],
        progression: [],
        breakdownChordDegree: 1,
        bpm: 75,
        barCount: 0,
        section: 'Verse',
        timeSignature: '4/4',
        stepsPerBar: 16,
        
        // HIT SONG VARIABLES
        trackMotif: [],
        drumPattern: [],
        bassPattern: [],   // 0=rest, 1=root, 2=fifth, 3=root up
        hihatPattern: [],  // 0=rest, 1=closed, 2=ghost, 3=open
        pianoPattern: [],  // 0=rest, 1=chord, 2=dyad, 3=arpeggio, 4=octave, 5=passing
        pianoPatternAlt: [],  // alternate pattern for bar alternation (hash-driven)
        pianoPatternIntro: [],  // sparse pattern for Intro only (hash-driven)
        pianoPatternBreakdown: [],  // very sparse pattern for Breakdown (hint of harmony)
        pianoDensity: 0.85,  // 0.45-0.95: prob to play non-rest hits (hash-driven)
        pianoUseBarAlternation: false,  // alternate patterns by bar (hash-driven)
        accordionPattern: [], // 0=rest, 1=full chord (sustained), 3=arpeggio note
        useSeventh: false, // 7th chords for Jazzy/Funk
        lastChordVoicing: null,
        activeLeadNote: null,
        params: { swing: 0.04, drumDensity: 0.5 },
        // Per-track note length variation (weighted pools — pick per note for organic feel)
        bassDurations: ['8n','8n','4n','8n','16n','4n','2n'],
        pianoChordDurations: ['4n','4n','2n','8n','4n'],
        pianoArpDurations: ['8n','8n','16n','4n','8n'],
        pianoDyadDurations: ['8n','4n','8n','8n'],
        pianoOctaveDurations: ['4n','8n','4n'],
        accordionChordDurations: ['2n','2n','1n','4n'],
        accordionArpDurations: ['4n','8n','4n','16n'],
        leadDurations: ['8n','4n','8n','16n'],
        bellDurations: ['8n','4n','8n'],
        leadStepMod: 0,
        bellStepMod: 0,
        // Within-track variation: section lengths (bars per section), bridge progression, motif transpose
        sectionLengths: [4, 4, 4, 4],
        totalCycleBars: 16,
        bridgeProgression: null,
        bridgeStartBar: 0,
        motifTranspose: 0
    };

    // Nodes
    let radioGroup, stopClick; 
    let keys, pad, bass, lead, accordion, bells, kick, snare, hihat, foley, fillArp;
    let masterFilter, chorus, delay, reverb, bitCrusher, compressor, limiter, masterHighPass, bassSubCut, masterCompressor, softClipper, clarityEQ, finalLimiter;
    let mobilePresenceFilter = null; // Optional: mobile-only presence boost (inserted in chain when isMobile())
    let vinylNoise, rainNoise, windNoise, fireNoise, tapeNoise, filterLFO, padVolumeLFO, analyser;
    let autoPanner, tremolo, vibrato;
    let pageVisible = true;
    let keepAliveAudio = null;
    let wakeLock = null;

    // ─── SPOTIFY CANVAS ─── Looping video background (mobile only)
    let canvasTimer = null;
    let canvasVisible = false;
    const CANVAS_DELAY_MS = 10000; // 10 seconds before video appears

    function startCanvasTimer() {
        const video = document.getElementById('canvas-video');
        if (!video || !video.src || video.src === window.location.href) return;
        if (window.innerWidth > 900) return; // Desktop — skip
        if (canvasVisible) return; // Already showing
        if (canvasDismissed) return; // User dismissed — don't auto-show until next track
        if (canvasTimer) clearTimeout(canvasTimer);
        // Start video playback now (user has interacted — stream started). On mobile, play() must run in or near a user gesture; by the time we show the canvas, video will already be playing.
        ensureCanvasVideoReady(video);
        canvasTimer = setTimeout(showCanvas, CANVAS_DELAY_MS);
    }

    /** Ensure canvas video is muted, playsinline, and playing so it autoplays on mobile when we reveal it. */
    function ensureCanvasVideoReady(video) {
        if (!video || window.innerWidth > 900) return;
        video.muted = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.play().catch(function() {});
    }

    let canvasDismissed = false; // User manually dismissed canvas

    function showCanvas() {
        const container = document.getElementById('canvas-container');
        const video = document.getElementById('canvas-video');
        const overlay = document.getElementById('canvas-overlay');
        const tapZone = document.getElementById('canvas-tap-zone');
        if (!container || !video || !video.src || video.src === window.location.href) return;
        if (window.innerWidth > 900) return; // Desktop guard
        video.muted = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.currentTime = 0;
        container.classList.add('visible');
        document.body.classList.add('canvas-active');
        // Do NOT call video.load() — it resets the video and iOS often blocks play() after load() when not in a user gesture. Just play().
        requestAnimationFrame(function() {
            requestAnimationFrame(function() {
                var p = video.play();
                if (p && typeof p.catch === 'function') p.catch(function() {});
                // Retry once after a short delay (iOS sometimes needs a second attempt after layout)
                if (video.paused) setTimeout(function() { video.play().catch(function() {}); }, 150);
            });
        });
        if (tapZone) tapZone.style.pointerEvents = 'auto';
        // Scroll main-stage to top so user sees the video first
        const stage = document.querySelector('.main-stage');
        if (stage) stage.scrollTop = 0;
        // Show floating track overlay
        if (overlay) {
            overlay.style.opacity = '';
            overlay.style.transform = '';
            syncCanvasOverlay();
            setTimeout(() => overlay.classList.add('visible'), 100);
        }
        canvasVisible = true;
        canvasDismissed = false;
    }

    function hideCanvas(userDismissed) {
        const container = document.getElementById('canvas-container');
        const video = document.getElementById('canvas-video');
        const overlay = document.getElementById('canvas-overlay');
        const tapZone = document.getElementById('canvas-tap-zone');
        if (container) container.classList.remove('visible');
        if (overlay) {
            overlay.classList.remove('visible');
            // Clear scroll-driven inline styles so overlay (and its time bar) fully hides; hero time bar is the only one shown when canvas is off
            overlay.style.opacity = '';
            overlay.style.transform = '';
        }
        document.body.classList.remove('canvas-active');
        if (video) video.pause();
        if (canvasTimer) { clearTimeout(canvasTimer); canvasTimer = null; }
        canvasVisible = false;
        // Keep tap zone active if user dismissed (so they can tap to bring it back)
        if (tapZone) tapZone.style.pointerEvents = userDismissed ? 'auto' : 'none';
        if (userDismissed) canvasDismissed = true;
    }

    /** Toggle canvas on/off when user taps the top half of the screen */
    function setupCanvasTapToggle() {
        const tapZone = document.getElementById('canvas-tap-zone');
        if (!tapZone) return;
        tapZone.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (canvasVisible) {
                // Dismiss — fade out video, fade in normal UI
                hideCanvas(true);
            } else if (canvasDismissed && state.isPlaying) {
                // Bring it back — user taps top half again
                showCanvas();
            }
        });
    }

    /** Push current track info into the canvas overlay */
    function syncCanvasOverlay() {
        const title = document.getElementById('playlist-title');
        const artist = document.getElementById('playlist-artist');
        const ct = document.getElementById('canvas-title');
        const ca = document.getElementById('canvas-artist');
        const csb = document.getElementById('canvas-style-badge');
        const cmb = document.getElementById('canvas-mood-badge');
        if (ct && title) ct.innerText = title.innerText;
        if (ca && artist) ca.innerText = artist.innerText;
        if (csb) csb.innerText = state.style || '';
        if (cmb) cmb.innerText = state.mood || '';
    }

    /** Scroll-aware canvas overlay: fades out as user scrolls to queue */
    function setupCanvasScroll() {
        const stage = document.querySelector('.main-stage');
        if (!stage) return;
        let ticking = false;
        stage.addEventListener('scroll', () => {
            if (!ticking) {
                ticking = true;
                requestAnimationFrame(() => {
                    handleCanvasScroll(stage);
                    ticking = false;
                });
            }
        }, { passive: true });
    }

    function handleCanvasScroll(stage) {
        if (!canvasVisible) return;
        const overlay = document.getElementById('canvas-overlay');
        if (!overlay) return;
        const scrollY = stage.scrollTop;
        const fadeDistance = 180; // px to fully fade out
        const progress = Math.min(1, scrollY / fadeDistance);
        // Fade out overlay as user scrolls
        overlay.style.opacity = 1 - progress;
        overlay.style.transform = `translateY(${-progress * 30}px)`;
    }

    // Initialize canvas interactions once DOM is ready
    (function initCanvasInteractions() {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setupCanvasScroll();
                setupCanvasTapToggle();
            });
        } else {
            setupCanvasScroll();
            setupCanvasTapToggle();
        }
    })();

    /**
     * Create a 1-second silent WAV blob.
     * Playing this on loop via <audio> does two critical things:
     * 1) Switches iOS from "ambient" to "playback" audio category → bypasses hardware mute switch
     * 2) Keeps the browser audio session alive when screen locks or app goes to background
     */
    function createSilentAudio() {
        const sampleRate = 8000;
        const numSamples = sampleRate; // 1 second of silence
        const buffer = new ArrayBuffer(44 + numSamples * 2);
        const view = new DataView(buffer);
        const w = (o, s) => { for (let i = 0; i < s.length; i++) view.setUint8(o + i, s.charCodeAt(i)); };
        w(0, 'RIFF');
        view.setUint32(4, 36 + numSamples * 2, true);
        w(8, 'WAVE');
        w(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);   // PCM
        view.setUint16(22, 1, true);   // mono
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);  // 16-bit
        w(36, 'data');
        view.setUint32(40, numSamples * 2, true);
        // All sample bytes default to 0 (silence)
        return new Blob([buffer], { type: 'audio/wav' });
    }

    /** Request screen wake lock (re-acquirable) */
    async function requestWakeLock() {
        if (!('wakeLock' in navigator)) return;
        try {
            wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener('release', () => { wakeLock = null; });
        } catch (e) {}
    }

    /** Aggressively resume all audio when returning to the page */
    function resumeAllAudio() {
        if (!state.isPlaying) return;
        if (currentChannel === 'lofi' && lofiEngine && lofiEngine.ctx && lofiEngine.ctx.state === 'suspended') {
            lofiEngine.ctx.resume().catch(function() {});
            return;
        }
        // Resume AudioContext (Tone path)
            const ctx = Tone.context.rawContext || (Tone.getContext && Tone.getContext().rawContext);
            if (ctx && ctx.state === 'suspended') {
            ctx.resume().then(() => {
                Tone.Transport.start();
                try { vinylNoise.start(); } catch(e) {}
                try { rainNoise.start(); } catch(e) {}
                try { windNoise.start(); } catch(e) {}
                try { fireNoise.start(); } catch(e) {}
                try { tapeNoise.start(); } catch(e) {}
                if (padVolumeLFO) try { padVolumeLFO.start(); } catch(e) {}
            }).catch(() => {});
        }
        // Resume keep-alive audio element (iOS/Android background)
        if (keepAliveAudio && keepAliveAudio.paused) {
            keepAliveAudio.play().catch(() => {});
        }
        // Re-acquire wake lock
        if (!wakeLock) requestWakeLock();
    }

    /** Set up all visibility/focus handlers to keep audio alive across mobile lifecycle events */
    function setupVisibilityHandling() {
        pageVisible = document.visibilityState === 'visible';

        // Primary: visibilitychange (tab switch, screen lock/unlock)
        document.addEventListener('visibilitychange', () => {
            pageVisible = document.visibilityState === 'visible';
            if (pageVisible) resumeAllAudio();
        });

        // Secondary: page focus/blur (some Android browsers)
        window.addEventListener('focus', () => { pageVisible = true; resumeAllAudio(); });
        window.addEventListener('blur', () => { pageVisible = false; });

        // Tertiary: resume on any user interaction after return
        const addResumeListeners = () => {
            const handler = () => {
                resumeAllAudio();
                document.removeEventListener('click', handler);
                document.removeEventListener('touchstart', handler);
                // Re-add after a delay so it catches future returns
                setTimeout(addResumeListeners, 1000);
            };
            document.addEventListener('click', handler, { once: true });
            document.addEventListener('touchstart', handler, { once: true });
        };
        addResumeListeners();

        // iOS-specific: pageshow event fires when returning via back/forward cache
        window.addEventListener('pageshow', (e) => {
            if (e.persisted) resumeAllAudio();
        });
    }

    /** Media Session API: lock screen controls & metadata */
    function setupMediaSession() {
        if (!('mediaSession' in navigator)) return;
        navigator.mediaSession.setActionHandler('play', () => { if (!state.isPlaying) togglePlay(); });
        navigator.mediaSession.setActionHandler('pause', () => { if (state.isPlaying) togglePlay(); });
        navigator.mediaSession.setActionHandler('nexttrack', () => {
            if (currentChannel === 'ambient') return; // Ambient uses mood cycle via nextBtn, not track skip
            if (currentChannel !== 'lofi' && !radioGroup) return;
            const now = Date.now() + state.timeOffset;
            const timeRemaining = (state.trackStartTime + state.trackDuration) - now;
            state.timeOffset += (timeRemaining + 100);
            updateAudioLogic();
        });
        // No previoustrack — this is a radio, can't go back
        navigator.mediaSession.setActionHandler('previoustrack', null);
        navigator.mediaSession.playbackState = 'playing';
    }

    function updateMediaSessionMetadata(title, artist) {
        if (!('mediaSession' in navigator)) return;
        navigator.mediaSession.metadata = new MediaMetadata({
            title: title,
            artist: artist,
            album: 'Lofi Radio — Live'
        });
    }

    // --- INIT ---
    async function initAudio() {
        if(isInitializing) return;
        isInitializing = true;

        await Tone.start();

        // Lo-Fi channel: same sound-making as Ambient — raw Web Audio, no Tone Transport/synths
        if (currentChannel === 'lofi') {
            if (!keepAliveAudio) {
                keepAliveAudio = new Audio();
                keepAliveAudio.loop = true;
                keepAliveAudio.setAttribute('playsinline', '');
                keepAliveAudio.setAttribute('webkit-playsinline', '');
                keepAliveAudio.src = URL.createObjectURL(createSilentAudio());
            }
            keepAliveAudio.play().catch(function() {});
            var lofiTrackInfo = getCurrentTrackInfo();
            state.currentSeed = lofiTrackInfo.seed;
            state.trackStartTime = lofiTrackInfo.startTime;
            state.trackDuration = lofiTrackInfo.duration;
            generateNewTrack(state.currentSeed);
            updateQueueUI();
            if (!lofiEngine) lofiEngine = new LofiEngine();
            lofiEngine.init().then(function() {
                lofiInitialized = true;
                lofiEngine.start();
                lofiPlaying = true;
                state.isPlaying = true;
                setupMediaSession();
                drawVisualizer();
                setInterval(updateAudioLogic, 1000);
                setInterval(updateUIProgress, 200);
                updatePlayButtonUI(true);
                startCanvasTimer();
            });
            await requestWakeLock();
            setupVisibilityHandling();
            isInitializing = false;
            return;
        }

        // Ambient uses raw Web Audio (no Tone), so it feels instant. Lo-Fi uses Tone.Transport + lookAhead, which adds delay.
        // Minimize scheduling delay: very short lookAhead so first beat and responses feel snappier.
        if (Tone.context.lookAhead !== undefined) Tone.context.lookAhead = 0.02;
        if (Tone.context.rawContext) {
            try {
                Tone.context.rawContext.latencyHint = 'interactive';
            } catch (e) {}
        }

        // Start silent audio loop — this is critical for mobile:
        // 1) iOS: switches audio category from "ambient" to "playback" → sound plays even when mute switch is on
        // 2) iOS/Android: keeps the browser audio session alive when screen locks or app backgrounds
        if (!keepAliveAudio) {
            keepAliveAudio = new Audio();
            keepAliveAudio.loop = true;
            keepAliveAudio.setAttribute('playsinline', '');
            keepAliveAudio.setAttribute('webkit-playsinline', '');
            keepAliveAudio.src = URL.createObjectURL(createSilentAudio());
        }
        keepAliveAudio.play().catch(() => {});
        
        // Master output: Gain → final limiter (quality mastering — consistent ceiling, no clipping)
        finalLimiter = new Tone.Limiter(-1).toDestination();
        radioGroup = new Tone.Gain(1).connect(finalLimiter);
        
        stopClick = new Tone.MembraneSynth({
            pitchDecay: 0.008,
            octaves: 4,
            oscillator: { type: "square4" },
            envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
        }).toDestination();
        stopClick.volume.value = -20;

        // Mobile mastering: small speakers need less sub, more headroom, and a touch of presence
        const isMobile = () => {
            if (typeof window === 'undefined') return false;
            const touch = window.matchMedia('(pointer: coarse)').matches;
            const narrow = window.matchMedia('(max-width: 900px)').matches;
            return !!(touch || narrow);
        };

        // Mastering: lighter touch to avoid pump, clicks and “squashed” sound (ambient has none of this).
        // Single limiter with more headroom so transients aren’t crushed.
        limiter = new Tone.Limiter(-2).connect(radioGroup);
        const softClipCurve = (() => {
            const n = 256;
            const curve = new Float32Array(n);
            for (let i = 0; i < n; i++) {
                const x = (i / (n - 1)) * 2 - 1;
                curve[i] = Math.tanh(x * 0.9);
            }
            return curve;
        })();
        const masterTrim = new Tone.Gain(0.72).connect(limiter);
        softClipper = new Tone.WaveShaper(softClipCurve).connect(masterTrim);
        masterCompressor = new Tone.Compressor(-14, 1.2).connect(softClipper);
        masterCompressor.attack.value = 0.04;
        masterCompressor.release.value = 0.5;
        masterCompressor.knee.value = 24;
        clarityEQ = new Tone.Filter(2500, 'highshelf', -12);
        clarityEQ.gain.value = 1;
        clarityEQ.connect(masterCompressor);
        masterHighPass = new Tone.Filter(38, "highpass", -24).connect(clarityEQ);

        if (isMobile()) {
            masterHighPass.frequency.value = 55;
            limiter.threshold.value = -2.5;
            mobilePresenceFilter = new Tone.Filter(2400, 'highshelf', -12);
            mobilePresenceFilter.gain.value = 1.5;
            masterCompressor.disconnect(softClipper);
            masterCompressor.connect(mobilePresenceFilter);
            mobilePresenceFilter.connect(softClipper);
        }
        // Multiband: very gentle (high thresholds, low ratios) to avoid pump and CPU spikes
        compressor = new Tone.MultibandCompressor({
            lowFrequency: 180,
            highFrequency: 2200,
            low:  { threshold: -2, ratio: 1.2, attack: 0.05, release: 0.4 },
            mid:  { threshold: -4, ratio: 1.2, attack: 0.04, release: 0.45 },
            high: { threshold: -2, ratio: 1.2, attack: 0.03, release: 0.4 }
        }).connect(masterHighPass);
        masterFilter = new Tone.Filter(3200, "lowpass").connect(compressor);
        filterLFO = new Tone.LFO(0.05, 2800, 7500).start(); // Start with open filter — never close below 2.6k (clamped per-track)
        filterLFO.connect(masterFilter.frequency);
        
        // Effect bus: enough room so it feels like a broadcast, not dry synths in a void
        const reverbInputGain = new Tone.Gain(0.82).connect(masterFilter);
        reverb = new Tone.JCReverb(0.24).connect(reverbInputGain); // More room — less "tone app", more station
        delay = new Tone.PingPongDelay("8n", 0.08).connect(reverb);
        chorus = new Tone.Chorus(2, 2.5, 0.5).connect(delay).start(); 
        bitCrusher = new Tone.BitCrusher(16).connect(chorus); // 16-bit: less grit stacking, fewer harsh peaks that can crack

        autoPanner = new Tone.AutoPanner("1m").start().connect(delay); // Very slow panning — gentle stereo width
        tremolo = new Tone.Tremolo(1.5, 0.15).start().connect(bitCrusher); // Slow, subtle amplitude shimmer
        vibrato = new Tone.Vibrato(2, 0.03).connect(autoPanner); // Gentle pitch warmth, not wobble

        // Piano: THE LEAD INSTRUMENT — DIRECT path to compressor for maximum presence.
        // Bypasses masterFilter AND reverb (JCReverb wet=1 was eating the dry signal!).
        // Dry signal: keys → compressor → limiter → radioGroup → destination
        // Reverb send: keys → pianoReverbSend (quiet) → compressor (just for ambience)
        const pianoReverbSend = new Tone.JCReverb(0.22).connect(compressor);
        pianoReverbSend.wet.value = 1; // Send 100% wet — piano sits in the same room as the rest
        keys = new Tone.PolySynth(Tone.FMSynth, {
            volume: -8,
            harmonicity: 3,
            modulationIndex: 4,
            oscillator: { type: "sine" },
            envelope: { attack: 0.005, decay: 0.6, sustain: 0.25, release: 1.2 },
            modulation: { type: "sine" },
            modulationEnvelope: { attack: 0.002, decay: 0.25, sustain: 0, release: 0.4 }
        });
        if (keys.maxPolyphony !== undefined) keys.maxPolyphony = 12;
        keys.connect(compressor);  // DRY path — piano heard directly, no reverb eating it
        keys.connect(new Tone.Gain(0.24).connect(pianoReverbSend)); // WET send — moderate so dense sections don't overload
        // Pad: very quiet background only — NOT a drone, just occasional warmth (limited voices = less buildup)
        pad = new Tone.PolySynth(Tone.Synth, { volume: -34, oscillator: { type: "sine" }, envelope: { attack: 1.2, decay: 0.6, sustain: 0.15, release: 1.0 } }).connect(reverb);
        if (pad.maxPolyphony !== undefined) pad.maxPolyphony = 6;
        padVolumeLFO = new Tone.LFO(0.06, -40, -32).start(); // Pad very quiet — subtle background only
        padVolumeLFO.connect(pad.volume);

        // Bass: Deep sub with punch — sine FM through lowpass for warmth + attack presence.
        // Sub-cut (38Hz) removes rumble that can cause strange speaker noise; 500Hz lowpass keeps hip-hop thump.
        bassSubCut = new Tone.Filter(38, "highpass", -24);
        if (isMobile()) bassSubCut.frequency.value = 58; // Match master: less sub on small speakers
        const bassFilter = new Tone.Filter(500, "lowpass", -12).connect(compressor);
        bassSubCut.connect(bassFilter);
        bass = new Tone.FMSynth({
            harmonicity: 1,
            modulationIndex: 1.2,
            oscillator: { type: "sine" },
            envelope: { attack: 0.005, decay: 0.35, sustain: 0.75, release: 0.8 },
            modulation: { type: "sine" },
            modulationEnvelope: { attack: 0.003, decay: 0.2, sustain: 0.08, release: 0.3 },
            volume: -10
        }).connect(bassSubCut); 
        lead = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.12, release: 0.7 }, volume: -32 }).connect(vibrato); 

        // Accordion: AM synthesis for reed-like lo-fi warmth
        // Routed through tremolo for natural wavering, then reverb for space
        accordion = new Tone.PolySynth(Tone.AMSynth, {
            volume: -24,
            harmonicity: 2,
            oscillator: { type: "square8" },
            envelope: { attack: 0.15, decay: 0.5, sustain: 0.55, release: 1.4 },
            modulation: { type: "sine" },
            modulationEnvelope: { attack: 0.1, decay: 0.3, sustain: 0.25, release: 0.6 }
        }).connect(tremolo);
        if (accordion.maxPolyphony !== undefined) accordion.maxPolyphony = 8;

        // Fill Arp — soft arpeggiated layer when piano rests
        fillArp = new Tone.PluckSynth({
            volume: -26,
            attackNoise: 0.6,
            dampening: 4000,
            resonance: 0.7
        }).connect(reverb);

        // Bells / glockenspiel — sparse high melody layer, sits above piano and lead
        bells = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.35 }, volume: -36 }).connect(reverb);

        kick = new Tone.MembraneSynth({ volume: -8, pitchDecay: 0.05, octaves: 6 }).connect(compressor);
        snare = new Tone.NoiseSynth({ volume: -9, envelope: { attack: 0.001, decay: 0.13, sustain: 0 } }).connect(masterFilter); 
        hihat = new Tone.MetalSynth({ volume: -18, frequency: 150, envelope: { attack: 0.001, decay: 0.04 } }).connect(reverb);
        
        // Foley Layer (Bird chirps, tape clicks etc.)
        foley = new Tone.Player("https://tonejs.github.io/audio/berklee/gong_1.mp3").connect(reverb); // Placeholder URL, in real app use generated noise bursts
        // Using a noise synth for foley instead to be self-contained
        foley = new Tone.NoiseSynth({ volume: -35, envelope: { attack: 0.02, decay: 0.08 } }).connect(reverb);

        const noiseGain = new Tone.Gain(1).connect(radioGroup);
        vinylNoise = new Tone.Noise("brown").start(); 
        vinylNoise.connect(new Tone.Filter(500, "highpass").connect(noiseGain));
        vinylNoise.volume.value = -48; // Audible crackle — record feel, not sterile synth
        
        rainNoise = new Tone.Noise("pink").start(); 
        rainNoise.connect(new Tone.AutoFilter("0.1hz").connect(noiseGain));
        rainNoise.volume.value = -99; 

        windNoise = new Tone.Noise("white").start(); 
        const windFilter = new Tone.Filter(800, "bandpass").connect(noiseGain);
        windNoise.connect(windFilter);
        windNoise.volume.value = -99;

        // Per-track ambient: fire crackle (brown + filter) and tape hiss (pink + highpass)
        fireNoise = new Tone.Noise("brown").start();
        const fireFilter = new Tone.Filter(1200, "lowpass", -12).connect(noiseGain);
        fireNoise.connect(fireFilter);
        fireNoise.volume.value = -99;

        tapeNoise = new Tone.Noise("pink").start();
        const tapeFilter = new Tone.Filter(400, "highpass").connect(noiseGain);
        tapeNoise.connect(new Tone.AutoFilter("0.08hz").connect(tapeFilter));
        tapeNoise.volume.value = -99; // Raised per-track when ambientLayer === 'tape'

        analyser = new Tone.Analyser("fft", 64);
        masterFilter.connect(analyser);

        // Request wake lock (re-acquirable on visibility change)
        await requestWakeLock();
        
        // Keep AudioContext running when tab is in background (prevents car/phone fragmentation)
        setupVisibilityHandling();

        state.isPlaying = true;
        isInitializing = false;
        
        const trackInfo = getCurrentTrackInfo();
        state.currentSeed = trackInfo.seed;
        state.trackStartTime = trackInfo.startTime;
        state.trackDuration = trackInfo.duration;
        
        generateNewTrack(state.currentSeed);
        updateQueueUI();
        
        startSequencer();
        drawVisualizer();
        
        // Set up lock screen controls (play/pause/skip)
        setupMediaSession();
        
        setInterval(updateAudioLogic, 1000); 
        setInterval(updateUIProgress, 200); 
        updatePlayButtonUI(true);
        
        // Start canvas video timer (if a video URL has been set)
        startCanvasTimer();
    }

    // Mix time-based pointer into a well-distributed seed using 32-bit safe arithmetic.
    // Previous version overflowed float64 precision (p*2654435761 for p~1.7e12 > 2^53),
    // causing consecutive tracks to get similar/identical seeds.
    function diversifySeed(pointer) {
        const p = Math.floor(pointer);
        // Split into two 32-bit halves to avoid float overflow
        const lo = p % 4294967296;        // lower 32 bits (exact — well within 2^53)
        const hi = Math.floor(p / 4294967296); // upper bits
        // Mix both halves with splitmix32 hash for excellent distribution
        let h = (lo ^ Math.imul(hi, 0x9e3779b9)) | 0;
        h = Math.imul(h ^ (h >>> 16), 0x85ebca6b);
        h = Math.imul(h ^ (h >>> 13), 0xc2b2ae35);
        return (h ^ (h >>> 16)) >>> 0;
    }

    // --- ENGINE ---
    function getCurrentTrackInfo() {
        const now = Date.now() + state.timeOffset;
        const currentHour = Math.floor(now / 3600000); 
        
        let pointer = currentHour * 3600000;
        let trackSeed = 0;
        let duration = 0;

        while (pointer < now + MAX_TRACK_MS) {
            const seedForDuration = diversifySeed(pointer);
            const trackRng = mulberry32(seedForDuration);
            duration = MIN_TRACK_MS + Math.floor(trackRng() * (MAX_TRACK_MS - MIN_TRACK_MS));
            
            if (pointer + duration > now) {
                trackSeed = seedForDuration;
                return { seed: trackSeed, startTime: pointer, duration: duration };
            }
            pointer += duration;
        }
    }

    function updateAudioLogic() {
        if (!state.isPlaying) return;
        
        const now = Date.now() + state.timeOffset;
        const timeRemaining = (state.trackStartTime + state.trackDuration) - now;

        if (timeRemaining < 5000 && !isTransitioning) {
            isTransitioning = true;
            if (radioGroup) radioGroup.gain.rampTo(0, 4);
            // Gentle darkening only — never pull filter below ~2.2 kHz so mix stays audible
            if (filterLFO) { filterLFO.max = 2200; filterLFO.frequency.rampTo(0.1, 4); }
            fadeUIText(false);
            hideCanvas(); // Fade out canvas during transition
        }

        if (timeRemaining <= 0) {
            const nextTrack = getCurrentTrackInfo();
            state.currentSeed = nextTrack.seed;
            state.trackStartTime = nextTrack.startTime;
            state.trackDuration = nextTrack.duration;
            
            generateNewTrack(state.currentSeed);
            if (currentChannel !== 'lofi') startSequencer(); // Lo-Fi uses LofiEngine (reads state each step)
            updateQueueUI();
            
            if (radioGroup) radioGroup.gain.rampTo(1, 4);
            if (filterLFO) { filterLFO.frequency.rampTo(0.05, 2); } // Restore LFO speed after transition
            fadeUIText(true);
            isTransitioning = false;
            startCanvasTimer(); // Restart 30s timer for new track
        }
    }

    function fadeUIText(fadeIn) {
        const opacity = fadeIn ? '1' : '0';
        document.getElementById('playlist-title').style.opacity = opacity;
        const artistEl = document.getElementById('playlist-artist');
        if(artistEl) artistEl.style.opacity = opacity;
        document.getElementById('bar-artist').style.opacity = opacity;
        document.getElementById('bar-title').style.opacity = opacity;
    }

    function generateNewTrack(seed) {
        currentRNG = mulberry32(seed);

        // Hip-hop / chill hop / trip hop: Chill, Groovy, Dreamy favored; Uplifting rare
        const moodWeights = [2.5, 0.15, 1.8, 2.2, 1.2]; // Chill, Uplifting, Groovy, Dreamy, Warm
        const moods = ['Chill', 'Uplifting', 'Groovy', 'Dreamy', 'Warm'];
        const moodTotal = moodWeights.reduce((a, b) => a + b, 0);
        let r = currentRNG() * moodTotal;
        for (let i = 0; i < moods.length; i++) {
            r -= moodWeights[i];
            if (r <= 0) { state.mood = moods[i]; break; }
        }
        if (!state.mood) state.mood = 'Chill';

        // Weighted style: Chill Hop, Jazzy, Neo-Soul, Vintage, Classic, Trip Hop much more likely
        const styleKeys = Object.keys(STYLES);
        const styleWeightArr = styleKeys.map(k => STYLE_WEIGHTS[k] != null ? STYLE_WEIGHTS[k] : 1);
        const styleTotal = styleWeightArr.reduce((a, b) => a + b, 0);
        r = currentRNG() * styleTotal;
        for (let i = 0; i < styleKeys.length; i++) {
            r -= styleWeightArr[i];
            if (r <= 0) { state.style = styleKeys[i]; break; }
        }
        if (!state.style) state.style = 'Chill Hop';
        const config = STYLES[state.style];

        state.key = NOTES[Math.floor(currentRNG() * NOTES.length)];
        const availableModes = MOOD_SCALES[state.mood];
        state.mode = availableModes[Math.floor(currentRNG() * availableModes.length)];
        state.scale = generateScale(state.key, state.mode);
        state.progression = generateProgression(state.mode, state.mood);
        state.breakdownChordDegree = state.progression[0];  // Section-specific: breakdown holds one chord
        
        let bpm = config.bpmRange[0] + Math.floor(currentRNG() * (config.bpmRange[1] - config.bpmRange[0]));
        if (state.mood === 'Groovy') bpm += 2; // Slight push for head-nod, not bright
        if (state.mood === 'Dreamy') bpm -= 1;
        state.bpm = Math.max(62, Math.min(90, bpm)); // Hip-hop / chill / trip hop: 62-90 BPM
        
        Tone.Transport.bpm.value = state.bpm; 

        state.params.swing = config.swing;
        state.params.drumDensity = config.drumDensity;
        
        // 1. Drum: weighted toward boom-bap, Dilla, chill hop, jazz hop, neo-soul, half-time
        const drumKeys = Object.keys(DRUM_LOOPS);
        const drumWeightArr = drumKeys.map(k => DRUM_WEIGHTS[k] != null ? DRUM_WEIGHTS[k] : 1);
        const drumTotal = drumWeightArr.reduce((a, b) => a + b, 0);
        r = currentRNG() * drumTotal;
        let drumKey = drumKeys[0];
        for (let i = 0; i < drumKeys.length; i++) {
            r -= drumWeightArr[i];
            if (r <= 0) { drumKey = drumKeys[i]; break; }
        }
        state.drumPattern = [...DRUM_LOOPS[drumKey]];
        
        // 2. Motif from hook contours (scale degrees 0–6, 7 = root up octave). Octave placement for drama.
        const contour = MOTIF_CONTOURS[Math.floor(currentRNG() * MOTIF_CONTOURS.length)];
        const baseOctave = 4;
        state.trackMotif = contour.map((deg) => {
            const safeDeg = Math.max(0, Math.min(deg, 7));
            const idx = safeDeg === 7 ? 0 : safeDeg % 7;
            const octave = safeDeg === 7 ? baseOctave + 1 : baseOctave + (safeDeg >= 5 && currentRNG() > 0.4 ? 1 : 0);
            return state.scale[idx] + octave;
        });

        // 3. Bass: style-consistent with drums (kick–bass lock) when we have a pair, else any pattern
        let bassKeys = Object.keys(BASS_PATTERNS);
        const paired = DRUM_BASS_PAIRS[drumKey];
        if (paired && paired.length > 0 && currentRNG() < 0.72) {
            const available = paired.filter(k => BASS_PATTERNS[k]);
            if (available.length > 0) bassKeys = available;
        }
        const bassKey = bassKeys[Math.floor(currentRNG() * bassKeys.length)];
        state.bassPattern = [...BASS_PATTERNS[bassKey]];

        // 4. Hi-hat: groove pattern with ghost notes and open hats
        const hhKeys = Object.keys(HIHAT_PATTERNS);
        const hhKey = hhKeys[Math.floor(currentRNG() * hhKeys.length)];
        state.hihatPattern = [...HIHAT_PATTERNS[hhKey]];

        // 5. Piano: mood-weighted pattern, density, bar alternation, intro pattern (all hash-driven)
        const moodPool = PIANO_MOOD_WEIGHTS[state.mood] || Object.keys(PIANO_PATTERNS);
        const poolKeys = moodPool.filter(k => PIANO_PATTERNS[k]);
        const pickFromPool = () => poolKeys[Math.floor(currentRNG() * poolKeys.length)];
        state.pianoDensity = 0.45 + currentRNG() * 0.5;  // 0.45–0.95
        state.pianoUseBarAlternation = currentRNG() < 0.4;  // 40% tracks alternate
        const mainKey = pickFromPool();
        state.pianoPattern = [...PIANO_PATTERNS[mainKey]];
        state.pianoPatternAlt = state.pianoUseBarAlternation ? (() => {
            const altKeys = poolKeys.filter(k => k !== mainKey);
            return altKeys.length ? [...PIANO_PATTERNS[altKeys[Math.floor(currentRNG() * altKeys.length)]]] : state.pianoPattern.slice();
        })() : [];
        const introPool = PIANO_INTRO_POOL.filter(k => PIANO_PATTERNS[k]);
        state.pianoPatternIntro = introPool.length ? [...PIANO_PATTERNS[introPool[Math.floor(currentRNG() * introPool.length)]]] : state.pianoPattern.slice();
        const breakdownPool = PIANO_BREAKDOWN_POOL.filter(k => PIANO_PATTERNS[k]);
        state.pianoPatternBreakdown = breakdownPool.length ? [...PIANO_PATTERNS[breakdownPool[Math.floor(currentRNG() * breakdownPool.length)]]] : [];

        // 6. Accordion: breathing sustained chords and gentle fills (exclude Lullaby for mature vibe)
        const accKeys = Object.keys(ACCORDION_PATTERNS).filter(k => k !== 'Lullaby');
        const accKey = accKeys[Math.floor(currentRNG() * accKeys.length)];
        state.accordionPattern = [...ACCORDION_PATTERNS[accKey]];

        // 7. Per-track ambient: one of rain, wind, fire crackle, or tape hiss (changes each song)
        const ambientOptions = ['rain', 'wind', 'fire', 'tape'];
        state.ambientLayer = ambientOptions[Math.floor(currentRNG() * ambientOptions.length)];
        
        state.useSeventh = (state.style === 'Jazzy' || state.style === 'Neo-Soul' || state.style === 'Vintage' || state.style === 'Chill Hop' || state.style === 'Trip Hop' || state.style === 'Classic');
        state.lastChordVoicing = null;

        // --- NOTE LENGTH VARIATION: per-track duration pools (shuffle weights for variety)
        const DURATION_POOLS = {
            bass: [['16n','8n','8n','4n','8n','4n','2n'], ['8n','8n','8n','4n','16n'], ['4n','8n','8n','8n','2n'], ['8n','16n','8n','4n','8n']],
            pianoChord: [['4n','4n','2n','8n','4n'], ['2n','4n','4n','4n'], ['4n','8n','4n','2n'], ['4n','4n','4n','8n','2n']],
            pianoArp: [['8n','8n','16n','4n'], ['8n','16n','8n','8n'], ['4n','8n','8n','16n'], ['8n','8n','4n','16n']],
            pianoDyad: [['8n','4n','8n','8n'], ['4n','8n','4n'], ['8n','8n','4n','8n']],
            pianoOctave: [['4n','8n','4n'], ['4n','4n','8n'], ['8n','4n']],
            accChord: [['2n','2n','1n','4n'], ['2n','4n','2n'], ['1n','2n','2n'], ['2n','2n','2n','4n']],
            accArp: [['4n','8n','4n','16n'], ['4n','4n','8n'], ['8n','4n','4n'], ['4n','16n','4n']]
        };
        state.bassDurations = DURATION_POOLS.bass[Math.floor(currentRNG() * DURATION_POOLS.bass.length)];
        state.pianoChordDurations = DURATION_POOLS.pianoChord[Math.floor(currentRNG() * DURATION_POOLS.pianoChord.length)];
        state.pianoArpDurations = DURATION_POOLS.pianoArp[Math.floor(currentRNG() * DURATION_POOLS.pianoArp.length)];
        state.pianoDyadDurations = DURATION_POOLS.pianoDyad[Math.floor(currentRNG() * DURATION_POOLS.pianoDyad.length)];
        state.pianoOctaveDurations = DURATION_POOLS.pianoOctave[Math.floor(currentRNG() * DURATION_POOLS.pianoOctave.length)];
        state.accordionChordDurations = DURATION_POOLS.accChord[Math.floor(currentRNG() * DURATION_POOLS.accChord.length)];
        state.accordionArpDurations = DURATION_POOLS.accArp[Math.floor(currentRNG() * DURATION_POOLS.accArp.length)];
        // Lead + bell: pick one melody rhythm profile per track (different note lengths & density per song)
        const melodyProfile = MELODY_RHYTHM_PROFILES[Math.floor(currentRNG() * MELODY_RHYTHM_PROFILES.length)];
        state.leadDurations = melodyProfile.lead.slice();
        state.bellDurations = melodyProfile.bell.slice();
        state.leadStepMod = melodyProfile.leadStepMod;
        state.bellStepMod = melodyProfile.bellStepMod;

        // --- TIME SIGNATURE: 4/4 (default), 3/4, or 6/8 for variety
        const timeSigKeys = Object.keys(TIME_SIGNATURES);
        const timeSigKey = timeSigKeys[Math.floor(currentRNG() * timeSigKeys.length)];
        state.timeSignature = timeSigKey;
        state.stepsPerBar = TIME_SIGNATURES[timeSigKey].stepsPerBar;
        // Use dedicated 3/4 & 6/8 patterns when applicable
        if (state.stepsPerBar === 12) {
            const d34 = Object.keys(DRUM_LOOPS_34);
            const b34 = Object.keys(BASS_PATTERNS_34);
            const p34 = Object.keys(PIANO_PATTERNS_34);
            const intro34 = ['Sparse34','Single34','Arp34','Dyad34'];
            const a34 = Object.keys(ACCORDION_PATTERNS_34);
            const h34 = Object.keys(HIHAT_PATTERNS_34);
            state.drumPattern = [...DRUM_LOOPS_34[d34[Math.floor(currentRNG() * d34.length)]]];
            state.bassPattern = [...BASS_PATTERNS_34[b34[Math.floor(currentRNG() * b34.length)]]];
            const main34 = p34[Math.floor(currentRNG() * p34.length)];
            state.pianoPattern = [...PIANO_PATTERNS_34[main34]];
            state.pianoPatternAlt = state.pianoUseBarAlternation ? (() => {
                const alt34 = p34.filter(k => k !== main34);
                return alt34.length ? [...PIANO_PATTERNS_34[alt34[Math.floor(currentRNG() * alt34.length)]]] : state.pianoPattern.slice();
            })() : [];
            state.pianoPatternIntro = [...PIANO_PATTERNS_34[intro34[Math.floor(currentRNG() * intro34.length)]]];
            const breakdown34 = ['Sparse34','Dyad34'];
            state.pianoPatternBreakdown = breakdown34.every(k => PIANO_PATTERNS_34[k]) ? [...PIANO_PATTERNS_34[breakdown34[Math.floor(currentRNG() * breakdown34.length)]]] : [];
            state.accordionPattern = [...ACCORDION_PATTERNS_34[a34[Math.floor(currentRNG() * a34.length)]]];
            state.hihatPattern = [...HIHAT_PATTERNS_34[h34[Math.floor(currentRNG() * h34.length)]]];
        }

        // --- 10x SOUND VARIATION: pick lofi hit patches per track (exclude toy piano for mature vibe)
        const KEY_PATCHES_ADULT = KEY_PATCHES.filter((_, i) => i !== 10); // index 10 = toy piano
        const keyIdx = Math.floor(currentRNG() * KEY_PATCHES_ADULT.length);
        const padIdx = Math.floor(currentRNG() * PAD_PATCHES.length);
        const bassIdx = Math.floor(currentRNG() * BASS_PATCHES.length);
        const leadIdx = Math.floor(currentRNG() * LEAD_PATCHES.length);
        const accIdx = Math.floor(currentRNG() * ACCORDION_PATCHES.length);
        const effectIdx = Math.floor(currentRNG() * EFFECT_PRESETS.length);
        const drumIdx = Math.floor(currentRNG() * DRUM_TONES.length);
        const dt = DRUM_TONES[drumIdx];
        state.hihatFreqDefault = dt.hihatFreq;
        state.hihatDecayDefault = dt.hihatDecay;
        // Tone synths only exist when not on lofi (Web Audio path)
        if (keys) {
            const keyBase = KEY_PATCHES_ADULT[keyIdx];
            const keyVar = {
                ...keyBase,
                harmonicity: Math.max(1.5, Math.min(7, keyBase.harmonicity * (0.85 + currentRNG() * 0.3))),
                modulationIndex: Math.max(2, Math.min(7, keyBase.modulationIndex * (0.9 + currentRNG() * 0.25))),
                envelope: {
                    ...keyBase.envelope,
                    decay: keyBase.envelope.decay * (0.8 + currentRNG() * 0.4),
                    sustain: Math.max(0.15, Math.min(0.5, keyBase.envelope.sustain * (0.85 + currentRNG() * 0.35))),
                    release: keyBase.envelope.release * (0.85 + currentRNG() * 0.35)
                },
                volume: Math.max(-10, Math.min(-4, keyBase.volume + (currentRNG() - 0.5) * 3))
            };
            keys.set(keyVar);
        }
        if (pad) pad.set(PAD_PATCHES[padIdx]);
        if (bass) {
            const bassPatch = BASS_PATCHES[bassIdx];
            const bassVol = Math.min(0, (bassPatch.volume || -4) + 4);  // +4 dB boost (was too low)
            bass.set({ ...bassPatch, modulationIndex: Math.min(bassPatch.modulationIndex || 1.2, 2), volume: bassVol });
        }
        if (lead) lead.set(LEAD_PATCHES[leadIdx]);
        if (accordion) accordion.set(ACCORDION_PATCHES[accIdx]);
        const bellIdx = Math.floor(currentRNG() * BELL_PATCHES.length);
        if (bells) bells.set(BELL_PATCHES[bellIdx]);
        state.bellProb = 0.02 + currentRNG() * 0.05; // 2–7% — very sparse, subtle accent only

        // --- PIANO-SILENT FILLS: arp, random elements — per-track variation so songs don't sound same
        const FILL_SECTIONS = ['Verse','Chorus','Climax','Breakdown','Intro'];
        const pickFillSections = (n) => {
            const shuffled = [...FILL_SECTIONS].sort(() => currentRNG() - 0.5);
            return shuffled.slice(0, Math.max(1, Math.floor(n)));
        };
        state.arpFillSections = pickFillSections(2 + Math.floor(currentRNG() * 2));     // 2-3 sections
        state.randomFillSections = pickFillSections(1 + Math.floor(currentRNG() * 2));  // 1-2 sections
        state.arpFillProb = 0.15 + currentRNG() * 0.18;     // 15-33%
        state.randomFillProb = 0.08 + currentRNG() * 0.1;   // 8-18%
        // Structural variation: section order differs per track (Verse→Climax→Chorus→Breakdown, etc.)
        const SECTION_ORDERS = [
            ['Verse','Chorus','Climax','Breakdown'],
            ['Verse','Climax','Chorus','Breakdown'],
            ['Verse','Chorus','Breakdown','Climax'],
            ['Verse','Breakdown','Chorus','Climax'],
            ['Chorus','Verse','Climax','Breakdown']
        ];
        state.sectionOrder = SECTION_ORDERS[Math.floor(currentRNG() * SECTION_ORDERS.length)];
        // Varying section lengths: 4/4/4/4 (default), 4/8/4/4, 4/4/8/4, or 6/4/4/4 so the loop isn't always the same grid
        const LENGTH_PRESETS = [
            [4, 4, 4, 4], [4, 4, 4, 4], [4, 4, 4, 4], [4, 4, 4, 4], [4, 4, 4, 4], [4, 4, 4, 4], [4, 4, 4, 4],
            [4, 8, 4, 4], [4, 4, 8, 4], [4, 4, 4, 8], [6, 4, 4, 4], [4, 6, 4, 4]
        ];
        state.sectionLengths = LENGTH_PRESETS[Math.floor(currentRNG() * LENGTH_PRESETS.length)];
        state.totalCycleBars = state.sectionLengths.reduce((a, b) => a + b, 0);
        // Bridge progression: second-half harmonic variation (different 4 chords) so the song isn't same 4 chords throughout
        const isMajor = state.mode === 'Major' || state.mode === 'Lydian' || state.mode === 'Mixolydian';
        const progPool = isMajor ? FAMOUS_PROGRESSIONS.major : FAMOUS_PROGRESSIONS.minor;
        if (currentRNG() < 0.5 && progPool.length > 0) {
            let bridge = progPool[Math.floor(currentRNG() * progPool.length)];
            const sameAsMain = bridge && bridge.length === 4 && state.progression.length === 4 && bridge.every((d, i) => d === state.progression[i]);
            if (!bridge || bridge.length !== 4 || sameAsMain) {
                const other = progPool.filter(p => p && p.length === 4 && !p.every((d, i) => state.progression[i] === d));
                bridge = other.length > 0 ? other[Math.floor(currentRNG() * other.length)] : null;
            }
            state.bridgeProgression = bridge && bridge.length === 4 ? bridge : null;
            state.bridgeStartBar = state.bridgeProgression ? (4 + Math.floor(state.totalCycleBars * 0.45)) : 0;
        } else {
            state.bridgeProgression = null;
            state.bridgeStartBar = 0;
        }
        // Motif variation: occasional octave transpose every other phrase so the hook isn't identical every cycle
        state.motifTranspose = currentRNG() < 0.4 ? 12 : 0;
        if (reverb || delay || chorus || kick || snare || hihat || bitCrusher || vinylNoise) {
            const ep = EFFECT_PRESETS[effectIdx];
            if (reverb && reverb.roomSize !== undefined) reverb.roomSize = ep.reverbDecay;
            if (delay && delay.wet) delay.wet.value = ep.delayWet;
            if (chorus) chorus.wet.value = ep.chorusWet;
            if (filterLFO) { filterLFO.min = ep.filterMin; filterLFO.max = ep.filterMax; }
            if (tremolo) tremolo.wet.value = ep.tremoloWet;
            if (vibrato) { if (vibrato.wet) vibrato.wet.value = ep.vibratoWet; else if (vibrato.depth) vibrato.depth.value = ep.vibratoWet; }
            if (kick && kick.envelope) kick.envelope.decay = dt.kickDecay;
            if (snare && snare.envelope) snare.envelope.decay = dt.snareDecay;
            if (hihat) {
                if (hihat.frequency) hihat.frequency.value = dt.hihatFreq;
                if (hihat.envelope) hihat.envelope.decay = dt.hihatDecay;
            }

            if (bitCrusher) {
                bitCrusher.wet.value = 0.12;
                bitCrusher.bits.value = Math.max(config.bitCrush || 8, 6);
            }
            if (tremolo) tremolo.wet.value = Math.min(tremolo.wet.value, 0.08);
            if (vibrato && vibrato.wet) vibrato.wet.value = Math.min(vibrato.wet.value, 0.04);
            if (filterLFO) {
                filterLFO.min = Math.max(filterLFO.min, 2600);
                filterLFO.max = Math.min(9000, filterLFO.max + 500);
            }

            if (vinylNoise) {
                const vinylLvl = -46 - currentRNG() * 6;
                vinylNoise.volume.rampTo(vinylLvl, 2);
            }
            const ambientVol = -34 - currentRNG() * 10;
            const rainLvl = state.ambientLayer === 'rain' ? ambientVol : -99;
            const windLvl = state.ambientLayer === 'wind' ? ambientVol : -99;
            const fireLvl = state.ambientLayer === 'fire' ? ambientVol : -99;
            const tapeLvl = state.ambientLayer === 'tape' ? ambientVol : -99;
            if (rainNoise) rainNoise.volume.rampTo(rainLvl, 1);
            if (windNoise) windNoise.volume.rampTo(windLvl, 1);
            if (fireNoise) fireNoise.volume.rampTo(fireLvl, 1);
            if (tapeNoise) tapeNoise.volume.rampTo(tapeLvl, 1);
        }

        const meta = generateMetadata(seed);

        // Update lock screen "Now Playing" info
        updateMediaSessionMetadata(meta.title, meta.artist);
        
        setTimeout(() => {
            document.getElementById('playlist-title').innerText = meta.title;
            const artistEl = document.getElementById('playlist-artist');
            if(artistEl) { artistEl.innerText = meta.artist; artistEl.style.display = 'block'; }
            document.getElementById('bar-title').innerText = meta.title;
            document.getElementById('bar-artist').innerText = meta.artist;
            document.getElementById('style-badge').innerText = state.style;
            document.getElementById('mood-badge').innerText = state.mood; 
            document.getElementById('bpm-badge').innerText = `${state.bpm} BPM • ${state.timeSignature}`;
            
            let color = config.color;
            if(state.mood === 'Uplifting') color = '#10b981'; 
            if(state.mood === 'Groovy') color = '#d946ef';
            if(state.mood === 'Dreamy') color = '#60a5fa';
            if(state.mood === 'Warm') color = '#f59e0b';
            document.documentElement.style.setProperty('--dynamic-color', color);

            // Sync canvas overlay if visible
            if (canvasVisible) syncCanvasOverlay();
        }, 1000); 

        state.barCount = 4;
        state.section = 'Verse';
        canvasDismissed = false; // Reset dismiss on new track
    }

    function generateMetadata(seed) {
        let rng = mulberry32(seed);
        const titleA = TITLES_A[Math.floor(rng() * TITLES_A.length)];
        const titleB = TITLES_B[Math.floor(rng() * TITLES_B.length)];
        const artistA = ARTISTS_A[Math.floor(rng() * ARTISTS_A.length)];
        const artistB = ARTISTS_B[Math.floor(rng() * ARTISTS_B.length)];
        return { title: `${titleA} ${titleB}`, artist: `${artistA} ${artistB}` };
    }

    function updateQueueUI() {
        const queueContainer = document.getElementById('queue-container');
        queueContainer.innerHTML = '';
        const header = document.createElement('div');
        header.className = 'queue-header';
        header.textContent = 'Up next';
        queueContainer.appendChild(header);
        
        let pointer = state.trackStartTime; 
        let trackRng, dur, seed;

        seed = diversifySeed(pointer);
        trackRng = mulberry32(seed);
        let currentDur = MIN_TRACK_MS + Math.floor(trackRng() * (MAX_TRACK_MS - MIN_TRACK_MS));
        pointer += currentDur;

        for (let i = 1; i <= 8; i++) {
            seed = diversifySeed(pointer);
            trackRng = mulberry32(seed);
            dur = MIN_TRACK_MS + Math.floor(trackRng() * (MAX_TRACK_MS - MIN_TRACK_MS));
            
            const nextMeta = generateMetadata(seed);
            const nextStyle = getStyleForSeed(seed);
            addTrackRow(queueContainer, i, nextMeta, nextStyle, false);
            pointer += dur;
        }
    }

    function getStyleForSeed(seed) {
        const rng = mulberry32(seed);
        const styleKeys = Object.keys(STYLES);
        const styleWeightArr = styleKeys.map(k => STYLE_WEIGHTS[k] != null ? STYLE_WEIGHTS[k] : 1);
        const styleTotal = styleWeightArr.reduce((a, b) => a + b, 0);
        let r = rng() * styleTotal;
        for (let i = 0; i < styleKeys.length; i++) {
            r -= styleWeightArr[i];
            if (r <= 0) return styleKeys[i];
        }
        return styleKeys[0];
    }

    function addTrackRow(container, num, meta, styleName, isActive) {
        const div = document.createElement('div');
        div.className = `queue-row ${isActive ? 'active' : ''}`;
        div.innerHTML = `
            <div class="q-num">${isActive ? '▶' : num}</div>
            <div class="q-info">
                <div class="q-title">${meta.title}</div>
                <div class="q-artist">${meta.artist}</div>
            </div>
            <div class="q-meta">${styleName}</div>
            <div class="q-meta"></div>
        `;
        container.appendChild(div);
    }

    function generateScale(root, modeName) {
        const rootIdx = NOTES.indexOf(root);
        const intervals = MODES[modeName];
        return intervals.map(i => NOTES[(rootIdx + i) % 12]);
    }
    
    function getChord(degree, scale, octave = 3, addSeventh = false) {
        const r = (degree - 1 + 7) % 7;
        const t = (r + 2) % 7;
        const f = (r + 4) % 7;
        const chord = [scale[r] + octave, scale[t] + octave, scale[f] + octave];
        if (addSeventh) {
            const s = (r + 6) % 7;
            chord.push(scale[s] + octave);
        }
        return chord;
    }

    // Voice leading: pick the chord inversion closest to the previous chord's register
    function voiceLead(chordNotes, prevChord) {
        if (!prevChord || !prevChord.length) return chordNotes;
        try {
            const midiNotes = chordNotes.map(n => Tone.Frequency(n).toMidi());
            const prevCenter = prevChord.reduce((s, n) => s + Tone.Frequency(n).toMidi(), 0) / prevChord.length;
            let best = chordNotes;
            let bestDist = Infinity;
            for (let inv = 0; inv < chordNotes.length; inv++) {
                const voicingMidi = midiNotes.map((m, i) => i < inv ? m + 12 : m);
                voicingMidi.sort((a, b) => a - b);
                const center = voicingMidi.reduce((s, m) => s + m, 0) / voicingMidi.length;
                const dist = Math.abs(center - prevCenter);
                if (dist < bestDist) {
                    bestDist = dist;
                    best = voicingMidi.map(m => Tone.Frequency(m, "midi").toNote());
                }
            }
            return best;
        } catch(e) { return chordNotes; }
    }
    
    function generateProgression(mode, mood) {
        const isMajor = mode === 'Major' || mode === 'Lydian' || mode === 'Mixolydian';
        let pool = isMajor ? FAMOUS_PROGRESSIONS.major : FAMOUS_PROGRESSIONS.minor;
        if (mode === 'Mixolydian') {
            const mixo = [[1, 7, 4, 1], [1, 4, 1, 7], [1, 4, 7, 1]];
            return mixo[Math.floor(currentRNG() * mixo.length)];
        }
        // Mood-aware: Chill/Dreamy prefer soulful minor progressions (contain 6 or 7, start on 1 or 6)
        if (mood && (mood === 'Chill' || mood === 'Dreamy') && !isMajor) {
            const soulful = pool.filter(prog => (prog[0] === 1 || prog[0] === 6) && prog.some(d => d === 6 || d === 7));
            if (soulful.length > 0 && currentRNG() < 0.7) pool = soulful;
        }
        if (mood && mood === 'Uplifting' && isMajor) {
            const release = pool.filter(prog => prog.indexOf(4) >= 0 && prog.indexOf(5) >= 0);
            if (release.length > 0 && currentRNG() < 0.5) pool = release;
        }
        return pool[Math.floor(currentRNG() * pool.length)];
    }
    
    function startSequencer() {
        Tone.Transport.cancel();
        if (Tone.Transport.state !== 'started') {
            Tone.Transport.start("+0.1");
        }
        let step = 0;
        const stepsPerBar = state.stepsPerBar;
        const totalCycleBars = state.totalCycleBars || 16;

        Tone.Transport.scheduleRepeat((time) => {
            const patIdx = step % stepsPerBar;
            const sixteenth = step % 4; 
            const config = STYLES[state.style];

            // Non-deterministic variation: unique seed per (phrase, bar-in-cycle, step) so each phrase sounds different
            const phraseIndex = Math.max(0, Math.floor((state.barCount - 4) / totalCycleBars));
            const cycleBar = (state.barCount - 4 + totalCycleBars) % totalCycleBars;
            const stepInPhrase = cycleBar * stepsPerBar + step;
            const seed = state.currentSeed + 77777 + (phraseIndex * totalCycleBars * stepsPerBar + stepInPhrase) * 31;
            let seqRNG = mulberry32(seed >>> 0);

            // Humanized timing: audible swing (off-beat delay) + per-hit micro-timing for human feel
            const swingOffset = state.params.swing * (sixteenth % 2 === 1 ? 1 : 0);
            const humanize = (seqRNG() - 0.5) * 0.024;  // ±12ms — actually audible groove
            const t = time + swingOffset + humanize;

            // Section awareness for layering
            const isIntro = state.section === 'Intro';
            const isVerse = state.section === 'Verse';
            const isChorus = state.section === 'Chorus';
            const isClimax = state.section === 'Climax';
            const isBreakdown = state.section === 'Breakdown';

            // Current chord: use bridge progression in second half of track for harmonic variation
            const progIdx = state.barCount % 4;
            const useBridge = state.bridgeProgression && state.barCount >= state.bridgeStartBar;
            const progression = useBridge ? state.bridgeProgression : state.progression;
            const degree = isBreakdown ? (state.breakdownChordDegree ?? state.progression[0]) : progression[progIdx];
            const rawNotes = getChord(degree, state.scale, 4, state.useSeventh);
            const notes = voiceLead(rawNotes, state.lastChordVoicing);

            // ─── PIANO ─── Hash-driven: section pattern, bar alternation, density, articulations 1–5
            const effPattern = isIntro && state.pianoPatternIntro.length ? state.pianoPatternIntro
                : isBreakdown && state.pianoPatternBreakdown && state.pianoPatternBreakdown.length ? state.pianoPatternBreakdown
                : (state.pianoUseBarAlternation && state.pianoPatternAlt.length && (state.barCount % 2 === 1)) ? state.pianoPatternAlt
                : state.pianoPattern;
            const pianoVal = effPattern[patIdx] || 0;
            // Section-specific piano density: Verse sparser, Chorus/Climax fuller
            const effectiveDensity = isVerse ? (state.pianoDensity || 0.85) * 0.72 : (state.pianoDensity || 0.85);
            const passDensity = pianoVal > 0 && (isBreakdown ? seqRNG() < 0.28 : seqRNG() < effectiveDensity);
            const allowPianoInBreakdown = isBreakdown && state.pianoPatternBreakdown && state.pianoPatternBreakdown.length;
            if (pianoVal > 0 && (allowPianoInBreakdown || !isBreakdown) && passDensity) {
                if (pianoVal === 1) {
                    const chordVel = isBreakdown ? (0.18 + seqRNG() * 0.08) : isClimax ? (0.72 + seqRNG() * 0.18) : isChorus ? (0.6 + seqRNG() * 0.15) : (0.45 + seqRNG() * 0.12);
                    const chordDur = state.pianoChordDurations[Math.floor(seqRNG() * state.pianoChordDurations.length)];
                    keys.triggerAttackRelease(notes, chordDur, t, chordVel);
                } else if (pianoVal === 2) {
                    const dyad = [notes[0], notes[2]];
                    const dyadVel = isBreakdown ? (0.15 + seqRNG() * 0.06) : isClimax ? (0.5 + seqRNG() * 0.15) : (0.4 + seqRNG() * 0.12);
                    const dyadDur = (state.pianoDyadDurations || ['8n','4n'])[Math.floor(seqRNG() * (state.pianoDyadDurations || ['8n']).length)];
                    keys.triggerAttackRelease(dyad, dyadDur, t, dyadVel);
                } else if (pianoVal === 3) {
                    const noteIdx = Math.floor(step / 2) % notes.length;
                    const arpVel = isBreakdown ? (0.12 + seqRNG() * 0.06) : 0.4 + seqRNG() * 0.12;
                    const arpDur = state.pianoArpDurations[Math.floor(seqRNG() * state.pianoArpDurations.length)];
                    keys.triggerAttackRelease(notes[noteIdx], arpDur, t, arpVel);
                } else if (pianoVal === 4) {
                    const oct = [notes[0], Tone.Frequency(notes[0]).transpose(12).toNote()];
                    const octVel = isBreakdown ? (0.14 + seqRNG() * 0.06) : isClimax ? (0.5 + seqRNG() * 0.12) : (0.38 + seqRNG() * 0.1);
                    const octDur = (state.pianoOctaveDurations || ['4n','8n'])[Math.floor(seqRNG() * (state.pianoOctaveDurations || ['4n']).length)];
                    keys.triggerAttackRelease(oct, octDur, t, octVel);
                } else if (pianoVal === 5) {
                    const passIdx = Math.min(2, notes.length - 1);
                    const passVel = isBreakdown ? (0.12 + seqRNG() * 0.05) : 0.35 + seqRNG() * 0.1;
                    const passDur = state.pianoArpDurations[Math.floor(seqRNG() * state.pianoArpDurations.length)];
                    keys.triggerAttackRelease(notes[passIdx], passDur, t, passVel);
                }
            }

            // ─── PIANO-SILENT FILLS: arp, random elements (only when piano is NOT playing)
            const pianoSilent = (pianoVal === 0 || isBreakdown);
            if (pianoSilent && fillArp) {
                const arpOk = state.arpFillSections && state.arpFillSections.includes(state.section);
                const randomOk = state.randomFillSections && state.randomFillSections.includes(state.section);
                // Section intensity: Verse/Chorus more fills, Intro/Breakdown gentler — structural variation
                const sectionMul = isBreakdown ? 0.7 : isIntro ? 0.6 : isVerse ? 1.1 : isChorus ? 0.9 : 1;
                const aProb = (state.arpFillProb || 0.22) * sectionMul;
                const rProb = (state.randomFillProb || 0.12) * sectionMul;
                // Fill Arp: soft arpeggiated single notes
                if (arpOk && seqRNG() < aProb) {
                    const arpIdx = (Math.floor(step / 2) + state.barCount) % notes.length;
                    const arpNote = notes[arpIdx];
                    const arpVel = 0.12 + seqRNG() * 0.08;
                    const arpDur = ['16n','8n','8n','16n'][Math.floor(seqRNG() * 4)];
                    fillArp.triggerAttackRelease(arpNote, arpDur, t, arpVel);
                }
                // Random: bells, pad swell, or foley texture — keeps structure varied
                if (randomOk && seqRNG() < rProb) {
                    const r = seqRNG();
                    if (r < 0.4 && bells) {
                        const bellNote = notes[Math.floor(seqRNG() * notes.length)];
                        bells.triggerAttackRelease(bellNote, '8n', t, 0.03 + seqRNG() * 0.03);
                    } else if (r < 0.75 && pad) {
                        const padNotes = getChord(degree, state.scale, 3, false).slice(0, 3);
                        pad.triggerAttackRelease(padNotes, '2n', t, 0.04 + seqRNG() * 0.03);
                    } else if (foley) {
                        foley.triggerAttackRelease('16n', t, 0.1 + seqRNG() * 0.08);
                    }
                }
            }

            // Update voice leading reference on bar start
            if (step % stepsPerBar === 0) {
                state.lastChordVoicing = notes;
            }
            // Pad: only in breakdowns as ambient fill — very gentle wash
            if (step % stepsPerBar === 0 && isBreakdown && seqRNG() > 0.5) {
                const padNotes = getChord(degree, state.scale, 3, false);
                pad.triggerAttackRelease(padNotes.slice(0, 3), "1m", t, 0.05);
            }

            // Chord anticipation: rhythmic push — 8% in chorus, 18% in climax (louder on climax)
            const anticStep = (stepsPerBar - 2);
            if (step % stepsPerBar === anticStep && (isChorus || isClimax) && seqRNG() < (isClimax ? 0.18 : 0.08)) {
                const nextDeg = state.progression[(state.barCount + 1) % 4];
                const antNotes = getChord(nextDeg, state.scale, 4, state.useSeventh);
                keys.triggerAttackRelease(antNotes, "16n", t, isClimax ? 0.28 : 0.15);
            }

            // ─── ACCORDION ─── Warm reed pads and gentle fills — lo-fi texture layer
            // Plays in Verse and Breakdown for warmth, complements piano; joins climax for fullness
            const accVal = state.accordionPattern[patIdx];
            if (accVal > 0 && !isIntro) {
                // Accordion plays most in Verse/Breakdown, lighter in Chorus, full in Climax for richness
                const accActive = isBreakdown || isVerse || isClimax || (isChorus && seqRNG() < 0.3);
                if (accActive) {
                    // Use octave 3 for warm, low register — sits under the piano
                    const accNotes = getChord(degree, state.scale, 3, state.useSeventh);
                    const accVoiced = voiceLead(accNotes, state.lastChordVoicing);
                    if (accVal === 1) {
                        // Sustained chord — varied length (2n/1n/4n); climax brings more presence
                        const accVel = isClimax ? (0.2 + seqRNG() * 0.1) : isBreakdown ? (0.1 + seqRNG() * 0.06) : (0.14 + seqRNG() * 0.08);
                        const accChordDur = state.accordionChordDurations[Math.floor(seqRNG() * state.accordionChordDurations.length)];
                        accordion.triggerAttackRelease(accVoiced.slice(0, 3), accChordDur, t, accVel);
                    } else if (accVal === 3) {
                        // Single arpeggio note — varied length for melodic fill
                        const noteIdx = Math.floor(step / 4) % accVoiced.length;
                        const arpVel = 0.1 + seqRNG() * 0.06;
                        const accArpDur = state.accordionArpDurations[Math.floor(seqRNG() * state.accordionArpDurations.length)];
                        accordion.triggerAttackRelease(accVoiced[noteIdx], accArpDur, t, arpVel);
                    }
                }
            }

            // ─── BASS ─── Hip-hop sub — punchy, always present in verse+chorus, follows the chord.
            // Octave 3 for presence (octave 2 was too low / inaudible on many speakers)
            if (!isIntro) {
                const bpVal = state.bassPattern[patIdx];
                if (bpVal > 0) {
                    const bassChord = getChord(degree, state.scale, 3, state.useSeventh);
                    let bassNote;
                    if (bpVal === 1) {
                        bassNote = bassChord[0];
                    } else if (bpVal === 3) {
                        bassNote = bassChord[1];
                    } else if (bpVal === 5) {
                        bassNote = bassChord[2];
                    } else if (bpVal === 7) {
                        const nextDeg = isBreakdown ? (state.breakdownChordDegree ?? state.progression[0]) : state.progression[(state.barCount + 1) % 4];
                        const nextChord = getChord(nextDeg, state.scale, 3, false);
                        bassNote = nextChord[0];
                    }
                    if (bassNote) {
                        // Breakdown: present but soft bass (was too quiet); Verse/Chorus: full punch, Climax: peak drive
                        const bassVel = isClimax ? (0.6 + seqRNG() * 0.2) : isBreakdown ? (0.28 + seqRNG() * 0.12) : (0.5 + seqRNG() * 0.15);
                        const bassDur = state.bassDurations[Math.floor(seqRNG() * state.bassDurations.length)];
                        bass.triggerAttackRelease(bassNote, bassDur, t, bassVel);
                    }
                }
            }

            // ─── LEAD MELODY ─── Audible hook; motif variation: transpose +12 every other phrase when set
            if (config.hasLead && !isIntro && !isBreakdown) {
                const leadProb = isClimax ? 0.38 : isChorus ? 0.2 : (isVerse ? 0.08 : 0);
                const stepMod = state.leadStepMod || 0;
                const allowStep = (stepMod === 0 && step % 8 === 0) || (stepMod === 1 && step % 8 === 0 && (step + state.barCount) % 2 === 0) || (stepMod === 2 && step % 16 === 0);
                if (leadProb > 0 && seqRNG() < leadProb && allowStep) {
                    const leadChord = getChord(degree, state.scale, 5, state.useSeventh);
                    const motifIdx = (Math.floor(step / 8) + state.barCount) % (state.trackMotif.length || 8);
                    let leadNote;
                    if (state.trackMotif[motifIdx] && seqRNG() < 0.58) {
                        leadNote = state.trackMotif[motifIdx];
                    } else {
                        leadNote = leadChord[motifIdx % leadChord.length];
                        if (seqRNG() < 0.12 && state.scale.length >= 7) {
                            const noteName = leadNote.replace(/\d/g, '');
                            const scaleIdx = state.scale.indexOf(noteName);
                            if (scaleIdx >= 0) {
                                const neighborIdx = (scaleIdx + (seqRNG() < 0.5 ? 1 : -1) + 7) % 7;
                                const oct = leadNote.match(/\d+/);
                                const octave = oct ? parseInt(oct[0], 10) : 5;
                                leadNote = state.scale[neighborIdx] + octave;
                            }
                        }
                    }
                    if (leadNote) {
                        if (state.motifTranspose && phraseIndex % 2 === 1) {
                            try { leadNote = Tone.Frequency(leadNote).transpose(state.motifTranspose).toNote(); } catch (e) {}
                        }
                        const leadVel = isClimax ? (0.22 + seqRNG() * 0.1) : isChorus ? (0.14 + seqRNG() * 0.08) : (0.1 + seqRNG() * 0.05);
                        const leadDur = state.leadDurations[Math.floor(seqRNG() * state.leadDurations.length)];
                        lead.triggerAttackRelease(leadNote, leadDur, t, leadVel);
                    }
                }
            }

            // ─── BELLS / GLOCKENSPIEL ─── Very subtle high accent only
            if (!isIntro && !isBreakdown && (state.bellProb || 0) > 0) {
                const bellProb = isClimax ? (state.bellProb * 1.1) : isChorus ? (state.bellProb * 1.05) : state.bellProb;
                const bellStepMod = state.bellStepMod || 0;
                const bellStepsOk = (bellStepMod === 0 && (step % 8 === 4 || step % 8 === 6)) || (bellStepMod === 1 && step % 8 === 4);
                if (seqRNG() < bellProb && bellStepsOk) {
                    const bellChord = getChord(degree, state.scale, 5, state.useSeventh);
                    const motifIdx = (Math.floor(step / 4) + state.barCount) % (state.trackMotif.length || 8);
                    const useMotif = seqRNG() < 0.5 && state.trackMotif[motifIdx];
                    let bellNote = useMotif ? state.trackMotif[motifIdx] : bellChord[Math.floor(seqRNG() * bellChord.length)];
                    if (bellNote) {
                        if (state.motifTranspose && phraseIndex % 2 === 1) {
                            try { bellNote = Tone.Frequency(bellNote).transpose(state.motifTranspose).toNote(); } catch (e) {}
                        }
                        const bellVel = isClimax ? (0.06 + seqRNG() * 0.04) : isChorus ? (0.05 + seqRNG() * 0.03) : (0.04 + seqRNG() * 0.02);
                        const bellDurs = state.bellDurations || state.leadDurations || ['8n'];
                        const bellDur = bellDurs[Math.floor(seqRNG() * bellDurs.length)];
                        bells.triggerAttackRelease(bellNote, bellDur, t, bellVel);
                    }
                }
            }

            // ─── DRUMS ─── Section-specific: Verse = sparser snare, Chorus/Climax = full, Breakdown = stripped (handled below)
            // Reset hi-hat to track default every step so open-hat decay never carries over (prevents stuck ringing)
            const defaultFreq = state.hihatFreqDefault != null ? state.hihatFreqDefault : 150;
            const defaultDecay = state.hihatDecayDefault != null ? state.hihatDecayDefault : 0.04;
            if (hihat.frequency) hihat.frequency.value = defaultFreq;
            if (hihat.envelope) hihat.envelope.decay = defaultDecay;

            if (!isIntro && !isBreakdown) {
                // --- KICK --- Velocity accents: beat 1 is louder, chorus hits harder, climax peaks
                if (state.drumPattern[patIdx] === 1) {
                    const beatOneBoost = (patIdx === 0) ? 0.1 : 0; // Accent beat 1
                    const sectionBoost = isClimax ? 0.15 : isChorus ? 0.08 : 0;
                    const kickVel = Math.min(0.95, 0.65 + seqRNG() * 0.2 + beatOneBoost + sectionBoost);
                    kick.triggerAttackRelease("C1", "8n", t, kickVel);
                }
                // Ghost kick: rare soft kick on empty slots for groove depth (4%)
                if (state.drumPattern[patIdx] === 0 && sixteenth === 3 && seqRNG() < 0.04) {
                    kick.triggerAttackRelease("C1", "16n", t, 0.12 + seqRNG() * 0.08);
                }

                // --- SNARE --- Verse: mask ~45% of snares for sparser feel; Chorus/Climax: full backbeat
                const snareSlot = state.drumPattern[patIdx] === 2;
                const verseSnareMask = isVerse && seqRNG() < 0.45; // Skip some snares in verse
                if (snareSlot && !verseSnareMask) {
                    const snareAccent = (patIdx === 4 || patIdx === Math.floor(stepsPerBar * 0.75)) ? 0.1 : 0; // Backbeat accent
                    const climaxBoost = isClimax ? 0.12 : 0;
                    const snareVel = Math.min(0.95, 0.55 + seqRNG() * 0.2 + snareAccent + climaxBoost);
                    snare.triggerAttackRelease("16n", t, snareVel);
                }
                // Ghost snare: fills the space between main hits (6%)
                if (state.drumPattern[patIdx] === 0 && (sixteenth === 1 || sixteenth === 3) && seqRNG() < 0.06) {
                    snare.triggerAttackRelease("32n", t, 0.06 + seqRNG() * 0.06);
                }
                // Snare fill: roll on last beat of every 4th bar; more frequent in climax
                const fillStart = Math.max(stepsPerBar - 4, 0);
                if (state.barCount % 4 === 3 && patIdx >= fillStart && seqRNG() < (isClimax ? 0.75 : 0.5)) {
                    snare.triggerAttackRelease("32n", t, 0.15 + seqRNG() * 0.1);
                }

                // --- HI-HAT --- Colorful: pitch varies per hit, 4 articulations
                const hhVal = state.hihatPattern && state.hihatPattern[patIdx] != null ? state.hihatPattern[patIdx] : 0;
                if (hhVal > 0) {
                    // Shift hi-hat frequency slightly per hit for "color" (140-200Hz range)
                    const freqShift = 140 + seqRNG() * 60;
                    if (hihat.frequency) hihat.frequency.value = freqShift;

                    if (hhVal === 1) {
                        // Closed — tight tick, varied velocity
                        const hhVel = 0.15 + seqRNG() * 0.12;
                        hihat.triggerAttackRelease("32n", t, hhVel);
                    } else if (hhVal === 2) {
                        // Ghost — barely-there texture, darker frequency
                        if (hihat.frequency) hihat.frequency.value = 120 + seqRNG() * 30;
                        hihat.triggerAttackRelease("64n", t, 0.04 + seqRNG() * 0.04);
                    } else if (hhVal === 3) {
                        // Open — longer ring, brighter frequency, more presence
                        if (hihat.frequency) hihat.frequency.value = 170 + seqRNG() * 50;
                        const openDecay = 0.06 + seqRNG() * 0.04; // Vary ring length
                        if (hihat.envelope) hihat.envelope.decay = openDecay;
                        hihat.triggerAttackRelease("16n", t, 0.22 + seqRNG() * 0.12);
                    } else if (hhVal === 4) {
                        // Accent — loud, bright closed hit, cuts through
                        if (hihat.frequency) hihat.frequency.value = 180 + seqRNG() * 40;
                        hihat.triggerAttackRelease("32n", t, 0.28 + seqRNG() * 0.12);
                    }
                }
                // Hi-hat fill: 32nd-note burst on last beat of every 8th bar; more in climax
                const hhFillStart = Math.max(stepsPerBar - 3, 0);
                if (state.barCount % 8 === 7 && patIdx >= hhFillStart && seqRNG() < (isClimax ? 0.85 : 0.6)) {
                    if (hihat.frequency) hihat.frequency.value = 160 + seqRNG() * 60;
                    hihat.triggerAttackRelease("64n", t, 0.18 + seqRNG() * 0.1);
                }
            } else if (isIntro) {
                // Intro: sparse hi-hat, building energy
                if (step % 8 === 0 && seqRNG() < 0.6) {
                    if (hihat.frequency) hihat.frequency.value = 140 + seqRNG() * 40;
                    hihat.triggerAttackRelease("32n", t, 0.08 + seqRNG() * 0.06);
                }
            } else if (isBreakdown) {
                // Breakdown: soft pulse — gentle kick on 1 & 3, ghost snare on 2 & 4 (keeps groove, not empty)
                if (patIdx === 0 || patIdx === stepsPerBar / 2) {
                    kick.triggerAttackRelease("C1", "8n", t, 0.22 + seqRNG() * 0.12);
                }
                if (patIdx === stepsPerBar / 4 || patIdx === Math.floor(stepsPerBar * 0.75)) {
                    snare.triggerAttackRelease("16n", t, 0.1 + seqRNG() * 0.06);
                }
                // Filtered, darker hi-hats — lower frequency, sparse
                const cycleBarBreakdown = (state.barCount - 4) % totalCycleBars;
                const barInSection = cycleBarBreakdown % 4;
                const isLastBarOfBreakdown = barInSection === 3;
                const hhProb = isLastBarOfBreakdown ? 0.65 : 0.4; // Build: more hats in last bar
                if (step % 4 === 0 && seqRNG() < hhProb) {
                    if (hihat.frequency) hihat.frequency.value = 110 + seqRNG() * 30;
                    hihat.triggerAttackRelease("32n", t, 0.06 + seqRNG() * 0.05);
                }
                // Occasional open hat swell in breakdown (more likely in last bar = build)
                if (step % stepsPerBar === 0 && seqRNG() < (isLastBarOfBreakdown ? 0.5 : 0.3)) {
                    if (hihat.frequency) hihat.frequency.value = 160 + seqRNG() * 40;
                    if (hihat.envelope) hihat.envelope.decay = 0.08;
                    hihat.triggerAttackRelease("8n", t, 0.1 + seqRNG() * 0.06);
                }
            }

            // Foley texture (deterministic occasional)
            if (seqRNG() < 0.003) foley.triggerAttackRelease("32n", t, 0.12);

            step = (step + 1) % stepsPerBar;
            if (step === 0) {
                state.barCount++;
                // Song structure: Intro(4) → [sections with variable lengths] cycle
                if (state.barCount < 4) {
                    state.section = 'Intro';
                } else {
                    const cycleBar = (state.barCount - 4) % totalCycleBars;
                    const order = state.sectionOrder || ['Verse','Chorus','Climax','Breakdown'];
                    const lengths = state.sectionLengths || [4, 4, 4, 4];
                    let acc = 0;
                    for (let i = 0; i < order.length; i++) {
                        if (cycleBar < acc + lengths[i]) {
                            state.section = order[i];
                            break;
                        }
                        acc += lengths[i];
                    }
                }
            }
        }, "16n");
    }

    function updateUIProgress() {
        if (!state.isPlaying) return;
        const now = Date.now() + state.timeOffset;
        const elapsed = now - state.trackStartTime;
        const duration = state.trackDuration;
        let percent = (elapsed / duration) * 100;
        percent = Math.max(0, Math.min(100, percent)); 
        document.getElementById('progress-bar').style.width = percent + '%';
        const mcBar = document.getElementById('mobile-progress-bar');
        if (mcBar) mcBar.style.width = percent + '%';
        // Canvas overlay progress
        const cvBar = document.getElementById('canvas-progress-bar');
        if (cvBar) cvBar.style.width = percent + '%';

        const s = Math.floor(elapsed / 1000);
        const totalS = Math.floor(duration / 1000);
        const m = Math.floor(s/60);
        const sec = (s%60).toString().padStart(2,'0');
        const timeStr = `${m}:${sec}`;
        document.getElementById('time-current').innerText = timeStr;
        const mcCur = document.getElementById('mobile-time-current');
        if (mcCur) mcCur.innerText = timeStr;
        // Canvas overlay time
        const cvCur = document.getElementById('canvas-time-current');
        if (cvCur) cvCur.innerText = timeStr;

        const totalM = Math.floor(totalS/60);
        const totalSec = (totalS%60).toString().padStart(2,'0');
        const totalStr = `${totalM}:${totalSec}`;
        document.getElementById('time-total').innerText = totalStr;
        const mcTot = document.getElementById('mobile-time-total');
        if (mcTot) mcTot.innerText = totalStr;
        // Canvas overlay total
        const cvTot = document.getElementById('canvas-time-total');
        if (cvTot) cvTot.innerText = totalStr;
    }

    function updatePlayButtonUI(playing) {
        const heroPlay = document.querySelector('#playBtn .icon-play');
        const heroPause = document.querySelector('#playBtn .icon-pause');
        if(heroPlay && heroPause) {
            heroPlay.style.display = playing ? 'none' : 'block';
            heroPause.style.display = playing ? 'block' : 'none';
        }
        const barPlay = document.querySelector('#barPlayBtn .icon-play');
        const barPause = document.querySelector('#barPlayBtn .icon-pause');
        if(barPlay && barPause) {
            barPlay.style.display = playing ? 'none' : 'block';
            barPause.style.display = playing ? 'block' : 'none';
        }
        const prompt = document.getElementById('play-prompt');
        if(prompt) prompt.style.display = playing ? 'none' : 'inline';
    }

    // --- AMBIENT CHANNEL: start / stop / 24h UI ---
    var ambientDataArray = new Uint8Array(256);
    function updateAmbientProgress() {
        if (!ambientPlaying) return;
        var elapsed = Math.floor((Date.now() - ambientStartTime) / 1000);
        var m = Math.floor(elapsed / 60);
        var sec = (elapsed % 60).toString().padStart(2, '0');
        var timeStr = m + ':' + sec;
        document.getElementById('time-current').innerText = timeStr;
        var mcCur = document.getElementById('mobile-time-current');
        if (mcCur) mcCur.innerText = timeStr;
        var cvCur = document.getElementById('canvas-time-current');
        if (cvCur) cvCur.innerText = timeStr;
        document.getElementById('time-total').innerText = '\u221E';
        var mcTot = document.getElementById('mobile-time-total');
        if (mcTot) mcTot.innerText = '\u221E';
        var cvTot = document.getElementById('canvas-time-total');
        if (cvTot) cvTot.innerText = '\u221E';
        var cycleSec = 120;
        var percent = ((elapsed % cycleSec) / cycleSec) * 100;
        document.getElementById('progress-bar').style.width = percent + '%';
        var mcBar = document.getElementById('mobile-progress-bar');
        if (mcBar) mcBar.style.width = percent + '%';
        var cvBar = document.getElementById('canvas-progress-bar');
        if (cvBar) cvBar.style.width = percent + '%';
    }
    function updateAmbientUI24h() {
        if (!ambientEngine || !ambientPlaying) return;
        var t24 = get24hProgress();
        var mood = AMBIENT_MOODS[currentAmbientMood];
        var rgb = (mood.color || '255,160,0').split(',').map(function(c) { return parseInt(c.trim(), 10); });
        var timeColors = getTimeOfDayColors(t24, rgb[0], rgb[1], rgb[2]);
        var hex = '#' + [timeColors.r, timeColors.g, timeColors.b].map(function(x) { return ('0' + x.toString(16)).slice(-2); }).join('');
        document.documentElement.style.setProperty('--dynamic-color', hex);
        var sceneName = ambientSceneNames[ambientEngine.currentScene] || 'GENERATING';
        document.getElementById('playlist-title').innerText = 'Aether Radio';
        var artistEl = document.getElementById('playlist-artist');
        if (artistEl) { artistEl.innerText = mood.name + ' · ' + sceneName; artistEl.style.display = 'block'; }
        document.getElementById('bar-title').innerText = 'Aether Radio';
        document.getElementById('bar-artist').innerText = mood.name + ' · ' + sceneName;
        document.getElementById('style-badge').innerText = 'Ambient';
        document.getElementById('mood-badge').innerText = mood.name;
        document.getElementById('bpm-badge').innerText = '24h';
    }
    function startAmbientChannel() {
        if (!ambientEngine) ambientEngine = new AmbientEngine();
        ambientEngine.setMood(currentAmbientMood);
        if (!ambientInitialized) {
            ambientEngine.init().then(function() {
                ambientInitialized = true;
                ambientStartTime = Date.now();
                ambientEngine.start();
                ambientPlaying = true;
                updatePlayButtonUI(true);
                updateAmbientUI24h();
                updateAmbientProgress();
                ambient24hInterval = setInterval(updateAmbientUI24h, 1000);
                ambientProgressInterval = setInterval(updateAmbientProgress, 200);
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'playing';
                    navigator.mediaSession.metadata = new MediaMetadata({ title: 'Aether Radio', artist: AMBIENT_MOODS[currentAmbientMood].name + ' · Ambient', album: 'Lofi Radio — Live' });
                }
                drawVisualizer();
            });
        } else {
            ambientStartTime = Date.now();
            if (ambientEngine.ctx && ambientEngine.ctx.state === 'suspended') ambientEngine.ctx.resume();
            ambientEngine.start();
            ambientPlaying = true;
            updatePlayButtonUI(true);
            updateAmbientUI24h();
            updateAmbientProgress();
            ambient24hInterval = setInterval(updateAmbientUI24h, 1000);
            ambientProgressInterval = setInterval(updateAmbientProgress, 200);
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'playing';
                navigator.mediaSession.metadata = new MediaMetadata({ title: 'Aether Radio', artist: AMBIENT_MOODS[currentAmbientMood].name + ' · Ambient', album: 'Lofi Radio — Live' });
            }
            drawVisualizer();
        }
    }
    function stopAmbientChannel() {
        if (ambientEngine) ambientEngine.stop();
        ambientPlaying = false;
        updatePlayButtonUI(false);
        if (ambient24hInterval) { clearInterval(ambient24hInterval); ambient24hInterval = null; }
        if (ambientProgressInterval) { clearInterval(ambientProgressInterval); ambientProgressInterval = null; }
        if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'paused';
        document.getElementById('playlist-title').innerText = 'Tune in to start';
        var artistEl = document.getElementById('playlist-artist');
        if (artistEl) { artistEl.style.display = 'none'; }
        document.getElementById('bar-title').innerText = 'Tune in';
        document.getElementById('bar-artist').innerText = '24/7 Lo-Fi · Beats to relax';
        document.getElementById('time-current').innerText = '0:00';
        document.getElementById('time-total').innerText = '--:--';
        document.getElementById('progress-bar').style.width = '0%';
        var mcCur = document.getElementById('mobile-time-current');
        if (mcCur) mcCur.innerText = '0:00';
        var mcTot = document.getElementById('mobile-time-total');
        if (mcTot) mcTot.innerText = '--:--';
        var mcBar = document.getElementById('mobile-progress-bar');
        if (mcBar) mcBar.style.width = '0%';
        var cvCur = document.getElementById('canvas-time-current');
        if (cvCur) cvCur.innerText = '0:00';
        var cvTot = document.getElementById('canvas-time-total');
        if (cvTot) cvTot.innerText = '--:--';
        var cvBar = document.getElementById('canvas-progress-bar');
        if (cvBar) cvBar.style.width = '0%';
    }
    function switchChannel(ch) {
        if (ch === currentChannel) return;
        if (currentChannel === 'lofi' && state.isPlaying) togglePlay();
        if (currentChannel === 'ambient' && ambientPlaying) stopAmbientChannel();
        currentChannel = ch;
        document.querySelectorAll('.nav-item').forEach(function(el) {
            el.classList.toggle('active', el.getAttribute('data-channel') === ch);
        });
        if (ch === 'lofi') {
            document.getElementById('style-badge').innerText = state.style || 'Classic';
            document.getElementById('mood-badge').innerText = state.mood || 'Neutral';
            document.getElementById('bpm-badge').innerText = (state.bpm || 80) + ' BPM';
        } else {
            document.getElementById('style-badge').innerText = 'Ambient';
            document.getElementById('mood-badge').innerText = AMBIENT_MOODS[currentAmbientMood].name;
            document.getElementById('bpm-badge').innerText = '24h';
        }
    }

    async function togglePlay() {
        if (currentChannel === 'ambient') {
            if (ambientPlaying) stopAmbientChannel(); else startAmbientChannel();
            return;
        }
        if (currentChannel === 'lofi') {
            if (lofiPlaying) {
                if (lofiEngine) lofiEngine.stop();
                lofiPlaying = false;
                state.isPlaying = false;
                updatePlayButtonUI(false);
                if (keepAliveAudio) keepAliveAudio.pause();
                if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'paused';
                hideCanvas();
            } else {
                if (lofiInitialized && lofiEngine) {
                    if (lofiEngine.ctx && lofiEngine.ctx.state === 'suspended') lofiEngine.ctx.resume();
                    lofiEngine.start();
                    lofiPlaying = true;
                    state.isPlaying = true;
                    updatePlayButtonUI(true);
                    if (keepAliveAudio && keepAliveAudio.paused) keepAliveAudio.play().catch(function() {});
                    if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'playing';
                } else {
                    await initAudio();
                }
            }
            return;
        }
        if(isInitializing) return;
        
        if(!radioGroup) {
            await initAudio();
            return;
        }

        if(state.isPlaying) {
            state.isPlaying = false;
            updatePlayButtonUI(false);
            stopClick.triggerAttackRelease("C2", "8n");
            radioGroup.gain.rampTo(0, 0.2); 
            setTimeout(() => {
                Tone.Transport.pause();
                vinylNoise.stop(); rainNoise.stop(); windNoise.stop(); fireNoise.stop(); tapeNoise.stop();
                if(padVolumeLFO) padVolumeLFO.stop();
                keys.releaseAll(); pad.releaseAll(); accordion.releaseAll();
                if (fillArp && fillArp.triggerRelease) fillArp.triggerRelease(Tone.now()); 
            }, 250);
            // Pause keep-alive audio & update lock screen state
            if (keepAliveAudio) keepAliveAudio.pause();
            if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'paused';
            hideCanvas(); // Pause canvas video
        } else {
            if(Tone.context.state !== 'running') await Tone.start();
            radioGroup.gain.rampTo(1, 0.08); // Short ramp avoids pop/crack on resume
            state.isPlaying = true;
            Tone.Transport.start();
            vinylNoise.start(); rainNoise.start(); windNoise.start(); fireNoise.start(); tapeNoise.start();
            if(padVolumeLFO) padVolumeLFO.start();
            // Resume keep-alive audio & update lock screen state
            if (keepAliveAudio) keepAliveAudio.play().catch(() => {});
            if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'playing';
            startCanvasTimer(); // Restart canvas timer on resume
            updatePlayButtonUI(true);
            drawVisualizer();
        }
    }

    function drawVisualizer() {
        var playing = currentChannel === 'ambient' ? ambientPlaying : (currentChannel === 'lofi' ? lofiPlaying : state.isPlaying);
        if (!playing) return;
        requestAnimationFrame(drawVisualizer);
        if (!pageVisible || document.visibilityState === 'hidden') return;
        var w = canvas.width;
        var h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        var bufferLength, dataArray;
        if (currentChannel === 'ambient' && ambientEngine) {
            ambientEngine.getAnalyserData(ambientDataArray);
            bufferLength = ambientDataArray.length;
            dataArray = ambientDataArray;
        } else if (currentChannel === 'lofi' && lofiEngine) {
            lofiEngine.getAnalyserData(lofiDataArray);
            bufferLength = lofiDataArray.length;
            dataArray = lofiDataArray;
        } else {
            if (!analyser) return;
            bufferLength = analyser.getValue().length;
            dataArray = analyser.getValue();
        }
        var barWidth = (w / bufferLength) * 2;
        var x = 0;
        for (var i = 0; i < bufferLength; i++) {
            var val = (dataArray[i] || 0) + 140; 
            var barHeight = Math.max(0, val * 2.5); 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.roundRect(x, h/2 - barHeight/2, barWidth, barHeight, 50);
            ctx.fill();
            x += barWidth + 2;
        }
    }

    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    
    if(window.innerWidth <= 900) {
        document.querySelector('.mobile-vibes-list').style.display = 'flex';
    }

    document.getElementById('playBtn').addEventListener('click', function() {
        if (currentChannel === 'ambient') { togglePlay(); return; }
        if (currentChannel === 'lofi') { togglePlay(); return; }
        if (Tone.Transport.state === 'started' || radioGroup) togglePlay(); else initAudio();
    });
    document.getElementById('barPlayBtn').addEventListener('click', function() {
        if (currentChannel === 'ambient') { togglePlay(); return; }
        if (currentChannel === 'lofi') { togglePlay(); return; }
        if (Tone.Transport.state === 'started' || radioGroup) togglePlay(); else initAudio();
    });

    document.querySelector('#nav-lofi').addEventListener('click', function() { switchChannel('lofi'); });
    document.querySelector('#nav-ambient').addEventListener('click', function() { switchChannel('ambient'); });
    
    document.getElementById('nextBtn').addEventListener('click', function() { 
        if (currentChannel === 'ambient') {
            var keys = Object.keys(AMBIENT_MOODS);
            var idx = keys.indexOf(currentAmbientMood);
            currentAmbientMood = keys[(idx + 1) % keys.length];
            if (ambientEngine) ambientEngine.setMood(currentAmbientMood);
            document.getElementById('mood-badge').innerText = AMBIENT_MOODS[currentAmbientMood].name;
            if (ambientPlaying) updateAmbientUI24h();
            return;
        }
        if (currentChannel === 'lofi') {
            var tNow = Date.now() + state.timeOffset;
            var tRem = (state.trackStartTime + state.trackDuration) - tNow;
            state.timeOffset += (tRem + 100);
            updateAudioLogic();
            return;
        }
        if(!radioGroup) return; 
        const now = Date.now() + state.timeOffset;
        const timeRemaining = (state.trackStartTime + state.trackDuration) - now;
        state.timeOffset += (timeRemaining + 100); 
        updateAudioLogic();
    });

</script>
</body>
</html>